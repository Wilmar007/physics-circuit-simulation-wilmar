
<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>General Physics 2 Simulation Laboratory</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #8B0000 0%, #DC143C 25%, #FFD700 50%, #8B0000 75%, #DC143C 100%);
            background-size: 400% 400%;
            animation: gradientShift 8s ease-in-out infinite;
            min-height: 100%;
            overflow-x: hidden;
        }

        // Unified induction drop handler used by the UI
        function handleInductionDropMaster(type, originalItem) {
            // Choose the visible induction zone (prefer the one in the active charging-method section)
            let zone = document.querySelector('.charging-method-section:not([style*="display: none"]) #inductionZone') || document.getElementById('inductionZone');
            if (!zone) zone = document.getElementById('inductionZone');
            if (!zone) return;

            if (!zone.droppedItems) zone.droppedItems = [];

            // Clear placeholder text on first drop
            if (zone.droppedItems.length === 0) {
                zone.innerHTML = '';
            }

            const simEl = document.createElement('div');
            simEl.className = 'induction-item';
            simEl.dataset.type = type;
            const chargeVal = originalItem ? (originalItem.getAttribute('data-charge') || '0') : '0';
            simEl.dataset.charge = chargeVal;

            // Basic visuals per type
            switch(type) {
                case 'charged-rod':
                case 'charged-rod-approach':
                    simEl.style.background = 'linear-gradient(145deg, #FFD700, #FFA500)';
                    simEl.innerHTML = '<div class="object-visual">‚ö°</div><div class="object-name">Charged Rod</div>';
                    simEl.classList.add('charge-effect');
                    break;
                case 'neutral-conductor':
                case 'neutral-conductor-sphere':
                    simEl.style.background = 'linear-gradient(145deg, #C0C0C0, #808080)';
                    simEl.innerHTML = '<div class="object-visual">‚ö™</div><div class="object-name">Neutral Conductor</div>';
                    break;
                case 'ground-wire':
                case 'ground-connection':
                    simEl.style.background = 'linear-gradient(145deg, #8B4513, #A0522D)';
                    simEl.innerHTML = '<div class="object-visual">üåç</div><div class="object-name">Ground Wire</div>';
                    break;
                case 'remove-ground':
                    simEl.style.background = 'linear-gradient(145deg, #FF6B6B, #DC143C)';
                    simEl.innerHTML = '<div class="object-visual">üîå</div><div class="object-name">Remove Ground</div>';
                    break;
                case 'electroscope':
                case 'electroscope-leaves':
                    simEl.style.background = 'linear-gradient(145deg, #DAA520, #B8860B)';
                    simEl.innerHTML = '<div class="object-visual">üìè</div><div class="object-name">Electroscope</div>';
                    break;
                case 'metal-can':
                    simEl.style.background = 'linear-gradient(145deg, #C0C0C0, #808080)';
                    simEl.innerHTML = '<div class="object-visual">ü•´</div><div class="object-name">Metal Can</div>';
                    break;
                default:
                    simEl.style.background = 'linear-gradient(145deg, #333, #222)';
                    simEl.innerHTML = `<div class="object-name">${type}</div>`;
                    break;
            }

            // remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.innerHTML = '√ó';
            removeBtn.onclick = function() {
                // remove from droppedItems
                zone.droppedItems = zone.droppedItems.filter(it => it.element !== simEl);
                simEl.remove();
                // re-analyze
                analyzeInductionProcess(zone.droppedItems, zone.querySelector('#fieldViz') || zone.querySelector('.induction-display') || zone);
            };
            simEl.appendChild(removeBtn);

            zone.appendChild(simEl);

            // tracking
            zone.droppedItems.push({ type: type, charge: chargeVal, element: simEl });

            // Re-run analysis for this zone
            // enable dragging inside the induction zone so proximity can change
            try { setupInductionDrag(simEl); } catch(e) {}
            analyzeInductionProcess(zone.droppedItems, zone.querySelector('#fieldViz') || zone.querySelector('.induction-display') || zone);
        }

        html {
            height: 100%;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .electricity-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .lightning {
            position: absolute;
            width: 2px;
            /* remove gold; use subtle white->blue gradient */
            background: linear-gradient(to bottom, rgba(255,255,255,0.0), #FFFFFF, #87CEEB);
            animation: lightning 3s infinite;
            opacity: 0;
        }

        @keyframes lightning {
            0%, 90%, 100% { opacity: 0; }
            5%, 85% { opacity: 1; }
        }

        .spark {
            position: absolute;
            width: 4px;
            height: 4px;
            /* use blue cyan spark instead of gold */
            background: #87CEEB;
            border-radius: 50%;
            animation: spark 2s infinite;
        }

        @keyframes spark {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
        }

        .main-container {
            position: relative;
            z-index: 2;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 3px solid #FFD700;
        }

        .main-title {
            font-size: 3rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 0.5rem;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 20px #FFD700; }
            to { text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 30px #FFD700, 0 0 40px #FFD700; }
        }

        .content-area {
            flex: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1200px;
            width: 100%;
            margin-bottom: 3rem;
        }

        .menu-box {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.2), rgba(220, 20, 60, 0.2));
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
        }

        .menu-box:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 15px 30px rgba(255, 215, 0, 0.4);
            border-color: #FFFFFF;
        }

        .menu-box::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }

        .menu-box:hover::before {
            animation: shine 0.5s ease-in-out;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
        }

        .menu-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            display: block;
        }

        .menu-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #FFFFFF;
            margin-bottom: 1rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .menu-description {
            color: #FFD700;
            font-size: 1rem;
            line-height: 1.4;
        }

        .simulation-area {
            display: none;
            width: 100%;
            max-width: 1200px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 2rem;
            backdrop-filter: blur(10px);
            border: 2px solid #FFD700;
        }

        .simulation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .back-button {
            background: linear-gradient(145deg, #DC143C, #8B0000);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(220, 20, 60, 0.4);
        }

        .simulation-title {
            color: #FFD700;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .drag-drop-container {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .drag-items {
            background: rgba(255, 215, 0, 0.1);
            border: 2px dashed #FFD700;
            border-radius: 10px;
            padding: 0.5rem;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            overflow-y: auto;
        }

        .drop-zone {
            background: rgba(220, 20, 60, 0.1);
            border: 2px dashed #DC143C;
            border-radius: 10px;
            padding: 1.5rem;
            min-height: 400px;
            position: relative;
        }

        .drop-zone.drag-over {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }

        .draggable-item {
            background: linear-gradient(145deg, #FFD700, #FFA500);
            color: #8B0000;
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            cursor: grab;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
            user-select: none;
        }

        .draggable-item:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }

        .draggable-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }



        .remove-btn {
            background: #FF4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .remove-btn:hover {
            background: #FF0000;
            transform: scale(1.1);
        }

        .clear-area-btn {
            background: linear-gradient(145deg, #FF6B6B, #DC143C);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .clear-area-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        @keyframes dropAnimation {
            0% { transform: scale(0) rotate(180deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(0deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        /* Overrides to match blue neon site theme and remove yellow/gold backgrounds */
        body {
            background: transparent !important;
            animation: none !important;
            background-size: initial !important;
        }

        /* Make primary containers translucent dark or transparent */
        .menu-box,
        .drag-items,
        .draggable-item,
        .drop-zone,
        .simulation-area,
        .explanation-panel,
        .footer,
        .quiz-container,
        .quiz-question,
        .real-object-visual {
            background: rgba(0,0,0,0.25) !important;
            box-shadow: none !important;
            border-color: rgba(0,150,255,0.14) !important;
        }

        /* Remove gold/yellow highlights from hover effects */
        .menu-box:hover { box-shadow: 0 15px 30px rgba(0,150,255,0.12) !important; }
        .menu-box::before { opacity: 0 !important; }

        /* Drop zone highlight should use translucent blue */
        .drop-zone.drag-over { border-color: rgba(0,150,255,0.28) !important; background: rgba(0,0,0,0.30) !important; }

        /* Keep neon/glow effects but prefer blue tints where earlier used gold */
        .physics-active { box-shadow: 0 0 18px rgba(0,180,255,0.9) !important; }
        .simulation-object .charge-indicator.positive { background: linear-gradient(145deg, rgba(0,150,255,0.2), rgba(0,100,200,0.2)) !important; }

        /* Ensure draggable items are readable on dark translucent background */
        .draggable-item { color: inherit !important; }

        /* Additional overrides for remaining yellow/gold backgrounds and highlights */
        .quiz-navigation,
        .quiz-option,
        .quiz-question,
        .competency-btn,
        .charging-method-btn,
        .real-object-visual,
        .explanation-text,
        .quiz-score {
            background: rgba(0,0,0,0.25) !important;
            border-color: rgba(0,150,255,0.14) !important;
            box-shadow: none !important;
        }

        /* Replace spark/glow yellow tints with blue where used in animations */
        .physics-active, .simulation-object .charge-indicator.positive, .quiz-score { box-shadow: 0 0 18px rgba(0,180,255,0.9) !important; }

        /* Override remaining gold box-shadows and highlights with blue tints */
        .menu-box:hover, .draggable-item:hover, .real-object-visual:hover, .quiz-option:hover {
            box-shadow: 0 12px 28px rgba(0,150,255,0.12) !important;
        }

        /* Replace small gold accents (pseudo elements/text) with blue tints */
        .rubbing-animation::before { color: #7EE7FF !important; }

        /* LEFT SIDEBAR (Charged / Neutral / Real Induction) - neon blue theme */
        /* Sidebar container: dark-blue gradient, soft cyan glow and border */
        .drag-items {
            background: linear-gradient(180deg, rgba(0,18,40,0.95), rgba(0,36,70,0.9)) !important;
            border: 1px solid rgba(0,200,255,0.18) !important;
            box-shadow: 0 6px 30px rgba(0,150,255,0.12), inset 0 0 40px rgba(0,36,70,0.35) !important;
            padding: 0.75rem !important;
            min-height: 420px !important;
            border-radius: 12px !important;
            transition: box-shadow 250ms ease, transform 250ms ease;
        }

        /* Scrollbar subtle and matching theme */
        .drag-items::-webkit-scrollbar { width: 10px; }
        .drag-items::-webkit-scrollbar-thumb { background: rgba(0,120,200,0.18); border-radius: 8px; }

        /* Section titles inside sidebar become cyan and more legible */
        .drag-items .section-title {
            color: #BEEBFF !important;
            font-weight: 700 !important;
            text-shadow: 0 0 8px rgba(0,180,255,0.18) !important;
            background: transparent !important;
            margin: 0.4rem 0 0.6rem 0 !important;
            padding: 0.25rem 0 !important;
        }

        /* Draggable item cards in sidebar: darker panels with subtle inner glow */
        .drag-items .draggable-item {
            background: linear-gradient(145deg, rgba(0,36,70,0.9), rgba(0,18,40,0.92)) !important;
            color: #E6FFFF !important;
            padding: 0.9rem 1rem !important;
            margin: 0.45rem 0 !important;
            border-radius: 8px !important;
            border: 1px solid rgba(0,160,255,0.12) !important;
            box-shadow: 0 6px 18px rgba(0,120,200,0.06), inset 0 0 12px rgba(0,80,140,0.18) !important;
            transform-origin: left center !important;
            transition: transform 180ms ease, box-shadow 180ms ease;
            font-weight: 700 !important;
            cursor: grab !important;
            text-align: center !important;
        }

        /* Brighter emoji/icons via text-shadow and stronger contrast */
        .drag-items .draggable-item { text-shadow: 0 0 8px rgba(0,200,255,0.18); }

        /* --- Text contrast fixes for sidebar (charged objects / particles) --- */
        /* Ensure all sidebar text is bright, fully opaque, and readable */
        .drag-items, .drag-items * {
            color: #e6f7ff !important;
            opacity: 1 !important;
            -webkit-font-smoothing: antialiased !important;
            text-rendering: optimizeLegibility !important;
        }

        /* Make item labels extra legible while preserving emoji colors */
        .drag-items .draggable-item {
            color: #e6f7ff !important;
            opacity: 1 !important;
            text-shadow: 0 0 6px rgba(0,255,255,0.12) !important;
        }

        /* Headings inside sidebar should be brighter cyan with a soft glow */
        .drag-items .section-title {
            color: #BEEBFF !important;
            font-weight: 800 !important;
            text-shadow: 0 0 6px rgba(0,255,255,0.4) !important;
            letter-spacing: 0.2px !important;
        }

        /* If any inline elements set muted colors, prefer this stronger rule for labels */
        .drag-items .draggable-item span,
        .drag-items .draggable-item strong,
        .drag-items .draggable-item em {
            color: #e6f7ff !important;
            opacity: 1 !important;
        }

        /* Slightly increase font-weight for particle labels to help readability */
        .drag-items .draggable-item { font-weight: 700 !important; }

        /* Hover: soft neon glow and slight scale-up to match main canvas intensity */
        .drag-items .draggable-item:hover {
            transform: scale(1.04) translateZ(0) !important;
            box-shadow: 0 12px 36px rgba(0,180,255,0.18), inset 0 0 18px rgba(0,120,200,0.06) !important;
        }

        /* Focus/active state for accessibility */
        .drag-items .draggable-item:focus,
        .drag-items .draggable-item:active {
            outline: 2px solid rgba(0,200,255,0.18) !important;
            transform: scale(1.02) !important;
        }

        /* Sidebar container glow to visually tie into main simulation area */
        .drag-drop-container > .drag-items {
            box-shadow: 0 0 40px rgba(0,150,255,0.08), inset 0 0 30px rgba(0,30,70,0.45) !important;
            border-left: 3px solid rgba(0,180,255,0.12) !important;
        }

        /* Keep other global overrides intact for non-sidebar elements */

        .section-title {
            color: #FFFFFF;
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        /* FORCE OVERRIDE: ensure sidebar text is fully visible on all displays */
        .sidebar *,
        .fundamental-particles *,
        .charged-objects * {
            opacity: 1 !important;
            color: #f0fbff !important;
            font-weight: 600 !important;
            text-shadow: 0 0 6px rgba(0,255,255,0.45) !important;
        }

        .sidebar h3,
        .sidebar h4 {
            color: #7df9ff !important;
            font-weight: 700 !important;
        }

        /* Apply same force-override to Fundamental/Subatomic panels and their parents */
        .particle-palette *,
        .particle-playground *,
        .playground-container *,
        .playground-area *,
        .demo-box * {
            opacity: 1 !important;
            color: #f0fbff !important;
            font-weight: 600 !important;
            text-shadow: 0 0 6px rgba(0,255,255,0.45) !important;
        }

        /* Ensure parent containers don't apply opacity/filters/backdrop-filter */
        .playground-container,
        .particle-palette,
        .particle-playground,
        .playground-area,
        .demo-box {
            opacity: 1 !important;
            filter: none !important;
            -webkit-filter: none !important;
            backdrop-filter: none !important;
        }

        /* Headings in these panels use the same brighter cyan as sidebar headings */
        .particle-palette .section-title,
        .particle-playground .section-title,
        .demo-box h4 {
            color: #7df9ff !important;
            font-weight: 700 !important;
            text-shadow: 0 0 6px rgba(0,255,255,0.35) !important;
        }

        .explanation-panel {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 1.5rem;
            margin-top: 2rem;
            border: 1px solid #FFD700;
        }

        .explanation-title {
            color: #FFD700;
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .explanation-text {
            color: #FFFFFF;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .footer {
            background: rgba(0, 0, 0, 0.5);
            text-align: center;
            padding: 1.5rem;
            border-top: 2px solid #FFD700;
            margin-top: auto;
        }

        .school-info {
            color: #FFD700;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .quiz-container {
            display: none;
            width: 100%;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 2rem;
            backdrop-filter: blur(10px);
            border: 2px solid #FFD700;
        }

        .quiz-question {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #FFD700;
        }

        .question-text {
            color: #FFFFFF;
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .quiz-options {
            display: grid;
            gap: 0.5rem;
        }

        .quiz-option {
            background: rgba(220, 20, 60, 0.2);
            border: 2px solid #DC143C;
            border-radius: 8px;
            padding: 1rem;
            color: #FFFFFF;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quiz-option:hover {
            background: rgba(255, 215, 0, 0.2);
            border-color: #FFD700;
        }

        .quiz-option.correct {
            background: rgba(50, 205, 50, 0.3);
            border-color: #32CD32;
        }

        .quiz-option.incorrect {
            background: rgba(255, 0, 0, 0.3);
            border-color: #FF0000;
        }

        .quiz-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            border: 1px solid #FFD700;
        }

        .quiz-nav-btn {
            background: linear-gradient(145deg, #DC143C, #8B0000);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin-right: 1rem;
        }

        .quiz-nav-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(220, 20, 60, 0.4);
        }

        .quiz-nav-btn.active {
            background: linear-gradient(145deg, #FFD700, #FFA500);
            color: #8B0000;
        }

        .quiz-score {
            color: #FFD700;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .quiz-section {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }

        .continuous-movement {
            transition: none !important;
        }

        .physics-active {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            animation: physicsGlow 2s ease-in-out infinite;
        }

        @keyframes physicsGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.9); }
        }

        @keyframes celebration {
            0% { transform: scale(1); }
            25% { transform: scale(1.1) rotate(2deg); }
            50% { transform: scale(1.15) rotate(-2deg); }
            75% { transform: scale(1.1) rotate(1deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .competency-nav {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .competency-btn {
            background: linear-gradient(145deg, rgba(220, 20, 60, 0.3), rgba(139, 0, 0, 0.3));
            color: #FFFFFF;
            border: 2px solid #DC143C;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .competency-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 20, 60, 0.4);
        }

        .competency-btn.active {
            background: linear-gradient(145deg, #FFD700, #FFA500);
            color: #8B0000;
            border-color: #FFD700;
        }

        .charging-method-nav {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .charging-method-btn {
            background: linear-gradient(145deg, rgba(220, 20, 60, 0.3), rgba(139, 0, 0, 0.3));
            color: #FFFFFF;
            border: 2px solid #DC143C;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .charging-method-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 20, 60, 0.4);
        }

        .charging-method-btn.active {
            background: linear-gradient(145deg, #FFD700, #FFA500);
            color: #8B0000;
            border-color: #FFD700;
        }

        .charging-method-section {
            animation: fadeIn 0.5s ease-in-out;
        }

        .real-object-animation {
            animation: realObjectFloat 3s ease-in-out infinite;
        }

        @keyframes realObjectFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-5px) scale(1.02); }
        }

        .real-object-visual {
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 0.6rem;
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
            border: 2px solid #FFD700;
            border-radius: 8px;
            margin: 0.3rem 0;
            cursor: grab;
            transition: all 0.3s ease;
            width: 100%;
            flex-shrink: 0;
            min-height: 50px;
        }

        .real-object-visual:hover {
            transform: translateY(-2px) scale(1.05);
            filter: drop-shadow(0 4px 8px rgba(255, 215, 0, 0.6));
            border-color: #FFA500;
        }

        .real-object-visual.dragging {
            opacity: 0.7;
            transform: rotate(3deg) scale(0.95);
            filter: drop-shadow(0 6px 12px rgba(255, 215, 0, 0.8));
        }

        .object-icon {
            font-size: 1.5rem;
            margin-right: 0.8rem;
            flex-shrink: 0;
        }

        .object-name {
            font-weight: bold;
            color: #8B0000;
            font-size: 0.9rem;
            text-align: left;
            line-height: 1.2;
            flex: 1;
        }

        .object-material {
            display: none;
        }

        .simulation-object {
            position: relative;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0.5rem;
            margin: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
            min-height: 60px;
            box-shadow: none;
            animation: realObjectFloat 3s ease-in-out infinite;
            backdrop-filter: none;
        }

        /* Visual-only: increase size of objects after they are dropped into simulation areas (~2x) */
        #simulationArea .simulation-object,
        #conductionSimulationArea .simulation-object,
        #inductionResult .simulation-object,
        #subatomicPlaygroundArea .subatomic-particle,
        #playgroundArea .subatomic-particle,
        #realWorldPlaygroundArea .real-world-particle {
            transform: scale(2) !important;
            transform-origin: center center !important;
            transition: transform 120ms ease !important;
            z-index: 1000 !important;
            display: inline-flex !important;
        }

        .simulation-object .object-icon {
            font-size: 2.5rem;
            margin-bottom: 0.3rem;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));
        }

        .simulation-object .object-name {
            color: #FFD700;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 0.8rem;
            text-align: center;
        }

        .simulation-object .charge-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            animation: chargeGlow 1.5s ease-in-out infinite;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .simulation-object .charge-indicator.positive {
            background: linear-gradient(145deg, #FF6B6B, #DC143C);
            color: white;
        }

        .simulation-object .charge-indicator.negative {
            background: linear-gradient(145deg, #87CEEB, #4682B4);
            color: white;
        }

        .electron-transfer-animation {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        .electron-flow {
            position: absolute;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #87CEEB, #4682B4);
            border-radius: 50%;
            box-shadow: 0 0 10px #87CEEB;
            animation: electronTransfer 2s ease-in-out;
        }

        @keyframes electronTransfer {
            0% {
                opacity: 1;
                transform: scale(1) translateX(0);
            }
            25% {
                opacity: 0.9;
                transform: scale(1.3) translateX(25%);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.5) translateX(50%);
            }
            75% {
                opacity: 0.6;
                transform: scale(1.2) translateX(75%);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateX(100%);
            }
        }

        @keyframes electronTransferDirect {
            0% {
                opacity: 1;
                transform: scale(1);
                left: var(--start-x, 0px);
                top: var(--start-y, 0px);
            }
            20% {
                opacity: 1;
                transform: scale(1.3);
            }
            50% {
                opacity: 0.9;
                transform: scale(1.1);
                left: calc((var(--start-x, 0px) + var(--end-x, 0px)) / 2);
                top: calc((var(--start-y, 0px) + var(--end-y, 0px)) / 2);
            }
            80% {
                opacity: 0.7;
                transform: scale(0.9);
            }
            100% {
                opacity: 0;
                transform: scale(0.5);
                left: var(--end-x, 0px);
                top: var(--end-y, 0px);
            }
        }

        .electron-transfer-particle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, #87CEEB, #4682B4);
            border-radius: 50%;
            box-shadow: 0 0 15px #87CEEB, 0 0 25px #4682B4;
            z-index: 1000;
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        .rubbing-animation {
            position: relative;
            overflow: visible;
        }

        .rubbing-animation::before {
            content: '‚ö°';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #FFD700;
            animation: sparkBurst 1s ease-out;
            z-index: 5;
        }

        @keyframes sparkBurst {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(2);
            }
        }

        .contact-spark {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #FFD700, #FFA500, transparent);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: sparkEffect 1s ease-out infinite;
        }

        @keyframes sparkEffect {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
        }

        .field-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(to right, #FFD700, #87CEEB);
            animation: fieldFlow 2s ease-in-out infinite;
        }

        @keyframes fieldFlow {
            0%, 100% { opacity: 0.3; transform: scaleX(0.8); }
            50% { opacity: 1; transform: scaleX(1.2); }
        }

        .electron-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #87CEEB;
            border-radius: 50%;
            animation: electronMove 2s linear;
        }

        @keyframes electronMove {
            0% { left: 10px; opacity: 1; }
            100% { left: 90%; opacity: 0; }
        }

        .charge-separation {
            text-align: center;
            margin-top: 1rem;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .positive-side {
            color: #FF6B6B;
        }

        .negative-side {
            color: #87CEEB;
        }

        .competency-section {
            animation: fadeIn 0.5s ease-in-out;
        }

        .charge-interaction-container {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 2px solid #FFD700;
        }

        .charge-demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-top: 1rem;
        }

        .charge-demo-box {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 1.5rem;
            border: 1px solid #DC143C;
        }

        .charge-rule-demos {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 2px solid #FFD700;
        }

        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-top: 1rem;
        }

        .demo-box {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 1.5rem;
            border: 1px solid #DC143C;
        }

        .particle-demo-area {
            min-height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px dashed #87CEEB;
            position: relative;
            overflow: hidden;
            margin-top: 1rem;
        }

        .playground-container {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .particle-palette {
            background: rgba(255, 215, 0, 0.1);
            border: 2px dashed #FFD700;
            border-radius: 10px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .particle-item {
            background: linear-gradient(145deg, #87CEEB, #4682B4);
            color: white;
            padding: 0.8rem;
            border-radius: 8px;
            cursor: grab;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
            user-select: none;
            font-size: 0.9rem;
        }

        .particle-item:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(135, 206, 235, 0.4);
        }

        .particle-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .playground-area {
            min-height: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid #FFD700;
            position: relative;
            overflow: hidden;
        }

        .subatomic-particle {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transition: all 0.3s ease;
            z-index: 10;
            cursor: grab;
        }

        .subatomic-particle.proton {
            background: radial-gradient(circle, #FF6B6B, #DC143C);
            box-shadow: 0 0 20px #FF6B6B;
        }

        .subatomic-particle.electron {
            background: radial-gradient(circle, #87CEEB, #4682B4);
            box-shadow: 0 0 20px #87CEEB;
        }

        .subatomic-particle.neutron {
            background: radial-gradient(circle, #FFD700, #FFA500);
            box-shadow: 0 0 20px #FFD700;
        }

        .subatomic-particle.positive-ion {
            background: radial-gradient(circle, #FF69B4, #DC143C);
            box-shadow: 0 0 20px #FF69B4;
        }

        .subatomic-particle.negative-ion {
            background: radial-gradient(circle, #00CED1, #4682B4);
            box-shadow: 0 0 20px #00CED1;
        }

        .real-world-particle {
            position: absolute;
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transition: all 0.3s ease;
            z-index: 10;
            cursor: grab;
            text-align: center;
            line-height: 1.1;
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .real-world-particle.balloon {
            background: radial-gradient(circle, #FF69B4, #DC143C);
            box-shadow: 0 0 20px #FF69B4;
        }

        .real-world-particle.comb {
            background: radial-gradient(circle, #8A2BE2, #4B0082);
            box-shadow: 0 0 20px #8A2BE2;
        }

        .real-world-particle.rod-positive {
            background: radial-gradient(circle, #FFD700, #FFA500);
            box-shadow: 0 0 20px #FFD700;
        }

        .real-world-particle.rod-negative {
            background: radial-gradient(circle, #00CED1, #008B8B);
            box-shadow: 0 0 20px #00CED1;
        }

        .real-world-particle.hair {
            background: radial-gradient(circle, #DEB887, #CD853F);
            box-shadow: 0 0 20px #DEB887;
        }

        .real-world-particle.paper {
            background: radial-gradient(circle, #F5F5DC, #D3D3D3);
            box-shadow: 0 0 20px #F5F5DC;
            color: #333;
        }

        .real-world-particle.dust {
            background: radial-gradient(circle, #A9A9A9, #696969);
            box-shadow: 0 0 20px #A9A9A9;
        }

        .real-world-particle.water-drop {
            background: radial-gradient(circle, #87CEEB, #4682B4);
            box-shadow: 0 0 20px #87CEEB;
        }

        .real-world-particle .object-icon {
            font-size: 1.8rem;
            margin-bottom: 0.2rem;
        }

        .real-world-particle .object-name {
            font-size: 0.7rem;
            font-weight: bold;
        }

        .polarized-particle {
            animation: polarizationEffect 2s ease-in-out infinite;
            border: 3px solid #FFD700 !important;
        }

        @keyframes polarizationEffect {
            0%, 100% { 
                border-color: #FFD700;
                box-shadow: 0 0 15px #FFD700;
            }
            50% { 
                border-color: #FFA500;
                box-shadow: 0 0 25px #FFA500, 0 0 35px #FFD700;
            }
        }

        .force-field {
            position: absolute;
            border-radius: 50%;
            border: 2px dashed;
            animation: fieldPulse 2s ease-in-out infinite;
            pointer-events: none;
        }

        .force-field.repulsion {
            border-color: #FF6B6B;
            background: radial-gradient(circle, transparent 60%, rgba(255, 107, 107, 0.1) 100%);
        }

        .force-field.attraction {
            border-color: #32CD32;
            background: radial-gradient(circle, transparent 60%, rgba(50, 205, 50, 0.1) 100%);
        }

        @keyframes subatomicRepel {
            0% { transform: translateX(0px); }
            50% { transform: translateX(var(--repel-distance, 40px)); }
            100% { transform: translateX(0px); }
        }

        @keyframes subatomicAttract {
            0% { transform: translateX(0px); }
            50% { transform: translateX(var(--attract-distance, -20px)); }
            100% { transform: translateX(0px); }
        }

        .repelling-particle {
            animation: subatomicRepel 2s ease-in-out infinite;
        }

        .attracting-particle {
            animation: subatomicAttract 2s ease-in-out infinite;
        }

        .demo-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .demo-btn {
            background: linear-gradient(145deg, #32CD32, #228B22);
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .demo-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(50, 205, 50, 0.4);
        }

        .demo-area {
            min-height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px dashed #87CEEB;
            position: relative;
            overflow: hidden;
        }

        .charge-particle {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transition: all 0.3s ease;
            z-index: 10;
        }

        .charge-particle.positive {
            background: radial-gradient(circle, #FF6B6B, #DC143C);
            box-shadow: 0 0 20px #FF6B6B;
        }

        .charge-particle.negative {
            background: radial-gradient(circle, #87CEEB, #4682B4);
            box-shadow: 0 0 20px #87CEEB;
        }

        .charge-particle.neutral {
            background: radial-gradient(circle, #FFD700, #FFA500);
            box-shadow: 0 0 20px #FFD700;
        }

        .interaction-line {
            position: absolute;
            height: 3px;
            z-index: 5;
            animation: forceFlow 1.5s ease-in-out infinite;
        }

        .interaction-line.repulsion {
            background: linear-gradient(to right, transparent, #FF6B6B, transparent);
        }

        .interaction-line.attraction {
            background: linear-gradient(to right, transparent, #32CD32, transparent);
        }

        .interaction-line.polarization {
            background: linear-gradient(to right, transparent, #FFD700, transparent);
        }

        .force-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(to right, transparent, #FFD700, transparent);
            z-index: 5;
            animation: forceFlow 1.5s ease-in-out infinite;
        }

        .force-line.repulsion {
            background: linear-gradient(to right, transparent, #FF6B6B, transparent);
        }

        .force-line.attraction {
            background: linear-gradient(to right, transparent, #32CD32, transparent);
        }

        @keyframes forceFlow {
            0%, 100% { opacity: 0.3; transform: scaleX(0.8); }
            50% { opacity: 1; transform: scaleX(1.2); }
        }

        @keyframes repelMotion {
            0% { transform: translateX(0px); }
            50% { transform: translateX(var(--repel-distance, 30px)); }
            100% { transform: translateX(0px); }
        }

        @keyframes attractMotion {
            0% { transform: translateX(0px); }
            50% { transform: translateX(var(--attract-distance, -15px)); }
            100% { transform: translateX(0px); }
        }

        .repelling {
            animation: repelMotion 2s ease-in-out infinite;
        }

        .attracting {
            animation: attractMotion 2s ease-in-out infinite;
        }

        .real-world-object {
            position: absolute;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: bold;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
        }

        .real-world-object.charged-positive {
            background: linear-gradient(145deg, rgba(255, 107, 107, 0.8), rgba(220, 20, 60, 0.8));
            color: white;
            border: 2px solid #FF6B6B;
        }

        .real-world-object.charged-negative {
            background: linear-gradient(145deg, rgba(135, 206, 235, 0.8), rgba(70, 130, 180, 0.8));
            color: white;
            border: 2px solid #87CEEB;
        }

        @media (max-width: 768px) {
            .charge-demo-grid {
                grid-template-columns: 1fr;
            }
            
            .demo-buttons {
                flex-direction: column;
            }
        }

        .atom-display {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 2rem auto;
            border: 2px dashed #FFD700;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nucleus {
            width: 60px;
            height: 60px;
            background: linear-gradient(145deg, #FF6B6B, #DC143C);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            position: relative;
            z-index: 2;
        }

        .electron-shell {
            position: absolute;
            width: 180px;
            height: 180px;
            border: 2px solid #87CEEB;
            border-radius: 50%;
            top: 10px;
            left: 10px;
        }

        .charge-display {
            text-align: center;
            color: #FFD700;
            font-size: 1.2rem;
            font-weight: bold;
            margin-top: 1rem;
        }

        .triboelectric-info {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #FFD700;
        }

        .charging-result {
            min-height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            border: 2px dashed #DC143C;
        }

        .induction-display {
            min-height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            position: relative;
            overflow: hidden;
        }

        .field-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle, transparent 2px, #FFD700 2px, #FFD700 4px, transparent 4px);
            background-size: 20px 20px;
            opacity: 0.3;
            animation: fieldPulse 2s ease-in-out infinite;
        }

        @keyframes fieldPulse {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.5; }
        }

        .calculation-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .calc-section {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            padding: 1.5rem;
            border: 1px solid #FFD700;
        }

        .problem-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #DC143C;
        }

        .calc-input {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            align-items: center;
        }

        .calc-input input {
            flex: 1;
            padding: 0.5rem;
            border: 2px solid #FFD700;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 1rem;
        }

        .calc-input button {
            background: linear-gradient(145deg, #32CD32, #228B22);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .calc-input button:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(50, 205, 50, 0.4);
        }

        .answer-feedback {
            margin-top: 0.5rem;
            font-weight: bold;
            min-height: 1.5rem;
        }

        .answer-feedback.correct {
            color: #32CD32;
        }

        .answer-feedback.incorrect {
            color: #FF6B6B;
        }

        .formula-reference {
            background: rgba(220, 20, 60, 0.1);
            border-radius: 10px;
            padding: 1.5rem;
            border: 1px solid #DC143C;
            height: fit-content;
        }

        .formula-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            color: #FFFFFF;
            line-height: 1.6;
        }

        .formula-box p {
            margin: 0.5rem 0;
            color: #FFD700;
        }

        .particle-animation {
            animation: particleFloat 2s ease-in-out infinite;
        }

        @keyframes particleFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(180deg); }
        }

        .charge-effect {
            position: relative;
            overflow: visible;
        }

        .charge-effect::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: inherit;
            background: linear-gradient(45deg, #FFD700, #87CEEB, #FFD700);
            z-index: -1;
            animation: chargeGlow 1.5s ease-in-out infinite;
        }

        @keyframes chargeGlow {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        @keyframes bondGlow {
            0%, 100% { 
                box-shadow: 0 0 10px #32CD32;
                background: linear-gradient(to right, #32CD32, #FFD700, #32CD32);
            }
            50% { 
                box-shadow: 0 0 20px #32CD32, 0 0 30px #FFD700;
                background: linear-gradient(to right, #FFD700, #32CD32, #FFD700);
            }
        }

        .bonded-particle {
            border: 3px solid #32CD32 !important;
            box-shadow: 0 0 15px #32CD32 !important;
            animation: bondedParticleGlow 2s ease-in-out infinite !important;
        }

        @keyframes bondedParticleGlow {
            0%, 100% { 
                border-color: #32CD32;
                box-shadow: 0 0 15px #32CD32;
            }
            50% { 
                border-color: #FFD700;
                box-shadow: 0 0 25px #FFD700, 0 0 35px #32CD32;
            }
        }

        @keyframes chargeBuildup {
            0% { 
                transform: translateX(-50%) scale(1);
                box-shadow: none;
            }
            50% { 
                transform: translateX(-50%) scale(1.05);
                box-shadow: 0 0 20px #FFD700;
            }
            100% { 
                transform: translateX(-50%) scale(1);
                box-shadow: 0 0 30px #FFD700, 0 0 50px #FF6B6B;
            }
        }

        @keyframes fieldLinePulse {
            0%, 100% { 
                opacity: 0.3; 
                transform: rotate(var(--rotation, 0deg)) scaleY(0.8);
            }
            50% { 
                opacity: 1; 
                transform: rotate(var(--rotation, 0deg)) scaleY(1.2);
            }
        }

        @media (max-width: 768px) {
            .main-title {
                font-size: 2rem;
            }
            
            .menu-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .drag-drop-container {
                grid-template-columns: 1fr;
            }
            
            .content-area {
                padding: 1rem;
            }

            .competency-nav {
                flex-direction: column;
                align-items: center;
            }

            .calculation-container {
                grid-template-columns: 1fr;
            }

            .calc-input {
                flex-direction: column;
                align-items: stretch;
            }
        }
        /* FORCE SIDEBAR VISIBILITY ‚Äì DO NOT REMOVE */
.sidebar,
.left-panel,
.objects-panel,
.fundamental-particles,
.charged-objects {
  opacity: 1 !important;
  filter: none !important;
}

/* FORCE TEXT VISIBILITY */
.sidebar *,
.left-panel *,
.objects-panel *,
.fundamental-particles *,
.charged-objects * {
  color: #ffffff !important;
  opacity: 1 !important;
  text-shadow: 0 0 6px rgba(0,255,255,0.5);
}
    </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="electricity-container" id="electricityContainer"></div>
  <div class="main-container">
   <header class="header">
    <h1 class="main-title" id="mainTitle">General Physics 2 Simulation Laboratory</h1>
   </header>
   <main class="content-area"><!-- Main Menu -->
    <div class="menu-grid" id="mainMenu">
     <div class="menu-box" onclick="showModule1()"><span class="menu-icon">‚ö°</span>
      <div class="menu-title">
       Elictric Charge
      </div>
      <div class="menu-description">
       Interactive simulations covering electrostatics, electric fields, and circuits
      </div>
     </div>
     <div class="menu-box" onclick="showRealWorld()"><span class="menu-icon">üåç</span>
      <div class="menu-title">
       Real World Applications
      </div>
      <div class="menu-description">
       Explore how physics concepts apply to everyday technology and phenomena
      </div>
     </div>
     <div class="menu-box" onclick="showDiscussion()"><span class="menu-icon">üí≠</span>
      <div class="menu-title">
       Discussion Hub
      </div>
      <div class="menu-description">
       Creative discussions and collaborative learning experiences
      </div>
     </div>
     <div class="menu-box" onclick="showQuiz()"><span class="menu-icon">üß†</span>
      <div class="menu-title">
       Interactive Quizzes
      </div>
      <div class="menu-description">
       Test your knowledge with engaging physics challenges
      </div>
     </div>
    </div><!-- Simulation -->
    <div class="simulation-area" id="module1Area">
     <div class="simulation-header"><button class="back-button" onclick="showMainMenu()">‚Üê Back to Menu</button>
      <h2 class="simulation-title">Electric Charge &amp; Electrostatics</h2>
     </div><!-- Competency Navigation -->
     <div class="competency-nav"><button class="competency-btn active" onclick="showCompetency('subatomic')">Subatomic Particles</button> <button class="competency-btn" onclick="showCompetency('charging')">Charging Methods</button> <button class="competency-btn" onclick="showCompetency('induction')">Induction &amp; Polarization</button> <button class="competency-btn" onclick="showCompetency('calculations')">Charge Calculations</button>
     </div><!-- Subatomic Particles Simulation -->
     <div class="competency-section" id="subatomic"><!-- Interactive Charge Behavior Simulation -->
      <div class="charge-interaction-container">
       <div class="section-title">
        Interactive Charge Behavior
       </div>
       <div class="charge-demo-grid"><!-- Like Charges Repel -->
        <div class="charge-demo-box">
         <h4 style="color: #FFD700; margin-bottom: 1rem;">Like Charges REPEL</h4>
         <div class="demo-buttons"><button class="demo-btn" onclick="demonstrateRepulsion('positive')">‚ö° Two Positive Charges</button> <button class="demo-btn" onclick="demonstrateRepulsion('negative')">‚ö° Two Negative Charges</button>
         </div>
         <div class="demo-area" id="repulsionDemo">
          <div style="color: #87CEEB; text-align: center; padding: 2rem;">
           Click a button above to see repulsion in action!
          </div>
         </div>
        </div><!-- Unlike Charges Attract -->
        <div class="charge-demo-box">
         <h4 style="color: #FFD700; margin-bottom: 1rem;">Unlike Charges ATTRACT</h4>
         <div class="demo-buttons"><button class="demo-btn" onclick="demonstrateAttraction('subatomic')">‚öõÔ∏è Proton + Electron</button> <button class="demo-btn" onclick="demonstrateAttraction('realworld')">üß≤ Real World Objects</button>
         </div>
         <div class="demo-area" id="attractionDemo">
          <div style="color: #87CEEB; text-align: center; padding: 2rem;">
           Click a button above to see attraction in action!
          </div>
         </div>
        </div>
       </div>
      </div><!-- Clickable Charge Rule Demonstrations -->
      <div class="charge-rule-demos">
       <div class="section-title">
        Interactive Charge Rule Demonstrations
       </div>
       <div class="demo-grid"><!-- Like Charges Repel Demo -->
        <div class="demo-box">
         <h4 style="color: #FFD700; margin-bottom: 1rem;">üìç Click to See: Like Charges REPEL</h4>
         <div class="demo-buttons"><button class="demo-btn" onclick="showSubatomicRepulsion('proton-proton')">‚öõÔ∏è Two Protons</button> <button class="demo-btn" onclick="showSubatomicRepulsion('electron-electron')">‚öõÔ∏è Two Electrons</button>
         </div>
         <div class="particle-demo-area" id="repelDemo">
          <div style="color: #87CEEB; text-align: center; padding: 2rem; font-style: italic;">
           Click a button above to see subatomic repulsion!
          </div>
         </div>
        </div><!-- Unlike Charges Attract Demo -->
        <div class="demo-box">
         <h4 style="color: #FFD700; margin-bottom: 1rem;">üìç Click to See: Unlike Charges ATTRACT</h4>
         <div class="demo-buttons"><button class="demo-btn" onclick="showSubatomicAttraction('proton-electron')">‚öõÔ∏è Proton + Electron</button> <button class="demo-btn" onclick="showSubatomicAttraction('ion-interaction')">‚öõÔ∏è Positive + Negative Ion</button>
         </div>
         <div class="particle-demo-area" id="attractDemo">
          <div style="color: #87CEEB; text-align: center; padding: 2rem; font-style: italic;">
           Click a button above to see subatomic attraction!
          </div>
         </div>
        </div><!-- Subatomic Particles Simulation -->
        <div class="demo-box" style="grid-column: 1 / -1;">
         <h4 style="color: #FFD700; margin-bottom: 1rem;">‚öõÔ∏è Subatomic Particles Simulation</h4>
         <div class="playground-container">
          <div class="particle-palette">
           <div class="section-title">
            Fundamental Particles
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="proton" data-charge="positive">
            ‚öõÔ∏è Proton (+)
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="electron" data-charge="negative">
            ‚öõÔ∏è Electron (-)
           </div>
          </div>
          <div class="particle-playground" id="particlePlayground">
           <div class="section-title">
            Subatomic Physics Zone
           </div>
           <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;"><button class="clear-area-btn" onclick="clearSubatomicSimulation()">üóëÔ∏è Clear All</button> <button class="clear-area-btn" id="subatomicToggle" onclick="toggleSubatomicSimulation()" style="background: linear-gradient(145deg, #32CD32, #228B22);">‚ñ∂Ô∏è Start Physics</button>
           </div>
           <div class="playground-area" id="subatomicPlaygroundArea">
            <div style="color: #FFD700; font-style: italic; text-align: center; padding: 3rem;">
             üéØ Drag protons and electrons here to see charge interactions!<br><span style="color: #FF6B6B; font-size: 0.9rem;">‚Ä¢ Two protons REPEL (push apart continuously)</span><br><span style="color: #87CEEB; font-size: 0.9rem;">‚Ä¢ Two electrons REPEL (push apart continuously)</span><br><span style="color: #32CD32; font-size: 0.9rem;">‚Ä¢ Proton and electron ATTRACT ‚Üí PERMANENT BOND!</span><br><span style="color: #FFD700; font-size: 0.8rem;">üí° Once bonded, the pair becomes NEUTRAL and ignores other particles!</span>
            </div>
           </div>
          </div>
         </div>
        </div><!-- Real World Objects Simulation -->
        <div class="demo-box" style="grid-column: 1 / -1; margin-top: 2rem;">
         <h4 style="color: #FFD700; margin-bottom: 1rem;">üåç Real World Objects Simulation</h4>
         <div class="playground-container">
          <div class="particle-palette">
           <div class="section-title">
            Charged Objects
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="balloon" data-charge="negative">
            üéà Balloon (-)
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="comb" data-charge="negative">
            üíá Comb (-)
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="rod-positive" data-charge="positive">
            üî¨ Glass Rod (+)
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="rod-negative" data-charge="negative">
            üñäÔ∏è Plastic Rod (-)
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="hair" data-charge="positive">
            üíá‚Äç‚ôÄÔ∏è Hair (+)
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="paper" data-charge="neutral">
            üìÑ Paper (neutral)
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="dust" data-charge="neutral">
            üí® Dust (neutral)
           </div>
           <div class="draggable-item particle-item" draggable="true" data-particle="water-drop" data-charge="neutral">
            üíß Water Drop (neutral)
           </div>
          </div>
          <div class="particle-playground" id="realWorldPlayground">
           <div class="section-title">
            Real World Physics Zone
           </div>
           <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;"><button class="clear-area-btn" onclick="clearRealWorldSimulation()">üóëÔ∏è Clear All</button> <button class="clear-area-btn" id="realWorldToggle" onclick="toggleRealWorldSimulation()" style="background: linear-gradient(145deg, #32CD32, #228B22);">‚ñ∂Ô∏è Start Physics</button>
           </div>
           <div class="playground-area" id="realWorldPlaygroundArea">
            <div style="color: #FFD700; font-style: italic; text-align: center; padding: 3rem;">
             üåç Drag real objects here to see electrostatic interactions!<br><span style="color: #FF6B6B; font-size: 0.9rem;">‚Ä¢ Like charges REPEL (balloon vs comb)</span><br><span style="color: #32CD32; font-size: 0.9rem;">‚Ä¢ Unlike charges ATTRACT (balloon vs hair)</span><br><span style="color: #87CEEB; font-size: 0.9rem;">‚Ä¢ Neutral objects get POLARIZED and attracted</span><br><span style="color: #FFD700; font-size: 0.8rem;">üí° See how static electricity works in everyday life!</span>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </div>
      <div class="explanation-panel">
       <div class="explanation-title">
        Understanding Electric Charge &amp; Force Laws
       </div>
       <div class="explanation-text"><strong>Coulomb's Law:</strong> Like charges repel each other, unlike charges attract each other. The force between charges follows F = k(q‚ÇÅq‚ÇÇ)/r¬≤, where the force is stronger when charges are closer together.
       </div>
       <div class="explanation-text"><strong>Subatomic Level:</strong> Protons (+1.6√ó10‚Åª¬π‚Åπ C) and electrons (-1.6√ó10‚Åª¬π‚Åπ C) attract each other, keeping electrons in orbit around the nucleus. Two protons repel each other, which is why atomic nuclei need neutrons for stability.
       </div>
       <div class="explanation-text"><strong>Real-world applications:</strong> This principle powers everything from the static cling in your clothes to the operation of touchscreens, printers, and air purification systems.
       </div>
       <div class="explanation-text" style="margin-top: 2rem; background: rgba(255, 215, 0, 0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #FFD700;"><strong style="color: #FFD700; font-size: 1.2rem;">üéì Student Discussion Points:</strong> <br><br><strong>1. Why do atoms stay together if protons repel each other?</strong> <br>
        ‚Ä¢ Protons in the nucleus DO repel each other strongly! <br>
        ‚Ä¢ But the <strong>strong nuclear force</strong> is even stronger at very short distances <br>
        ‚Ä¢ Neutrons act like "nuclear glue" - they help hold protons together <br>
        ‚Ä¢ This is why heavy atoms (lots of protons) need more neutrons to stay stable <br>
        ‚Ä¢ When this balance breaks down, atoms become radioactive! <br><br><strong>2. What keeps electrons from falling into the nucleus?</strong> <br>
        ‚Ä¢ Electrons are attracted to protons, but they have kinetic energy (they're moving!) <br>
        ‚Ä¢ It's like a satellite orbiting Earth - gravity pulls it down, but speed keeps it up <br>
        ‚Ä¢ Quantum mechanics says electrons exist in "probability clouds" around the nucleus <br>
        ‚Ä¢ The closer an electron gets, the faster it must move (uncertainty principle) <br><br><strong>3. How do we know charges are quantized (come in fixed amounts)?</strong> <br>
        ‚Ä¢ Robert Millikan's oil drop experiment (1909) proved it! <br>
        ‚Ä¢ He measured tiny oil drops and found charge always came in multiples of e = 1.6√ó10‚Åª¬π‚Åπ C <br>
        ‚Ä¢ You can't have half an electron - charge comes in "packets" <br>
        ‚Ä¢ This is why we say charge is "quantized" like steps on a staircase <br><br><strong>4. Real-world applications of charge interactions:</strong> <br>
        ‚Ä¢ <strong>Touchscreens:</strong> Detect changes in electric fields from your finger <br>
        ‚Ä¢ <strong>Laser printers:</strong> Use charged particles to attract toner to paper <br>
        ‚Ä¢ <strong>Air purifiers:</strong> Charge dust particles, then attract them to oppositely charged plates <br>
        ‚Ä¢ <strong>Paint spraying:</strong> Charge paint droplets so they're attracted to metal surfaces <br>
        ‚Ä¢ <strong>Photocopiers:</strong> Use light to create charge patterns that attract toner
       </div>
       <div class="explanation-text" style="margin-top: 1.5rem; background: rgba(255, 107, 107, 0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #FF6B6B;"><strong style="color: #FF6B6B; font-size: 1.2rem;">‚öõÔ∏è Atomic Bonding Simulation:</strong> <br><br><strong>What happens when you drag a proton and electron together?</strong> <br>
        ‚Ä¢ Watch them attract each other with increasing force as they get closer <br>
        ‚Ä¢ When they get very close, they form a permanent bond (hydrogen atom!) <br>
        ‚Ä¢ The bonded pair becomes electrically neutral and ignores other particles <br>
        ‚Ä¢ This is how atoms form - opposite charges attracting and binding together <br><br><strong>Why do two protons always repel?</strong> <br>
        ‚Ä¢ Both have positive charge - like trying to push two magnets together <br>
        ‚Ä¢ The closer they get, the stronger the repulsion becomes <br>
        ‚Ä¢ In real atoms, the strong nuclear force overcomes this at very short distances <br>
        ‚Ä¢ But in our simulation, we only see the electromagnetic force <br><br><strong>Try this:</strong> Create multiple proton-electron pairs and watch them form neutral atoms that don't interact with each other!
       </div>
       <div class="explanation-text" style="margin-top: 1.5rem; background: rgba(135, 206, 235, 0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #87CEEB;"><strong style="color: #87CEEB; font-size: 1.2rem;">üåç Real-World Object Interactions:</strong> <br><br><strong>Why do neutral objects get attracted to charged objects?</strong> <br>
        ‚Ä¢ This is called <strong>polarization</strong> - the charged object creates an electric field <br>
        ‚Ä¢ The field pushes electrons in the neutral object to one side <br>
        ‚Ä¢ This creates a temporary positive side and negative side (dipole) <br>
        ‚Ä¢ The closer side has opposite charge to the charged object - attraction wins! <br><br><strong>Examples you can observe:</strong> <br>
        ‚Ä¢ Charged balloon picks up small pieces of paper (paper gets polarized) <br>
        ‚Ä¢ Charged comb attracts your hair even before touching it <br>
        ‚Ä¢ Dust sticks to TV screens (screen charge polarizes dust particles) <br>
        ‚Ä¢ Water stream bends toward charged rod (water molecules are polar) <br><br><strong>Try the simulation:</strong> Mix charged and neutral objects to see polarization in action!
       </div>
      </div>
     </div><!-- Charging Methods Simulation -->
     <div class="competency-section" id="charging" style="display: none;"><!-- Charging Method Selection -->
      <div class="charging-method-nav"><button class="charging-method-btn active" onclick="showChargingMethod('rubbing')">‚ö° Charging by Rubbing</button> <button class="charging-method-btn" onclick="showChargingMethod('conduction')">üîå Charging by Conduction</button> <button class="charging-method-btn" onclick="showChargingMethod('induction')">üß≤ Charging by Induction</button>
      </div><!-- Charging by Rubbing Section -->
      <div class="charging-method-section" id="rubbing">
       <div class="drag-drop-container">
        <div class="drag-items">
         <div class="section-title">
          Real Objects for Rubbing
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="cat-fur" data-triboelectric="1">
          <div class="object-icon">
           üê±
          </div>
          <div class="object-name">
           Cat Fur
          </div>
          <div class="object-material">
           Natural cat fur
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="glass-rod" data-triboelectric="2">
          <div class="object-icon">
           üî¨
          </div>
          <div class="object-name">
           Glass Rod
          </div>
          <div class="object-material">
           Smooth glass surface
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="human-hair" data-triboelectric="3">
          <div class="object-icon">
           üíá‚Äç‚ôÄÔ∏è
          </div>
          <div class="object-name">
           Human Hair
          </div>
          <div class="object-material">
           Keratin protein
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="nylon-fabric" data-triboelectric="4">
          <div class="object-icon">
           üß∂
          </div>
          <div class="object-name">
           Nylon Fabric
          </div>
          <div class="object-material">
           Synthetic nylon fibers
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="wool-sweater" data-triboelectric="5">
          <div class="object-icon">
           üß•
          </div>
          <div class="object-name">
           Wool Sweater
          </div>
          <div class="object-material">
           Natural wool fibers
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="silk-cloth" data-triboelectric="6">
          <div class="object-icon">
           üßµ
          </div>
          <div class="object-name">
           Silk Cloth
          </div>
          <div class="object-material">
           Natural silk fibers
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="aluminum-foil" data-triboelectric="7">
          <div class="object-icon">
           üìÑ
          </div>
          <div class="object-name">
           Aluminum Foil
          </div>
          <div class="object-material">
           Thin aluminum sheet
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="paper-towel" data-triboelectric="8">
          <div class="object-icon">
           üßª
          </div>
          <div class="object-name">
           Paper Towel
          </div>
          <div class="object-material">
           Absorbent paper fibers
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="cotton-shirt" data-triboelectric="9">
          <div class="object-icon">
           üëï
          </div>
          <div class="object-name">
           Cotton T-Shirt
          </div>
          <div class="object-material">
           Natural cotton fibers
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="wooden-ruler" data-triboelectric="10">
          <div class="object-icon">
           üìè
          </div>
          <div class="object-name">
           Wooden Ruler
          </div>
          <div class="object-material">
           Dry wood surface
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="plastic-pen" data-triboelectric="11">
          <div class="object-icon">
           üñäÔ∏è
          </div>
          <div class="object-name">
           Plastic Pen
          </div>
          <div class="object-material">
           Hard plastic body
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="plastic-comb" data-triboelectric="12">
          <div class="object-icon">
           üíá
          </div>
          <div class="object-name">
           Plastic Comb
          </div>
          <div class="object-material">
           Hard plastic teeth
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="polyester-fabric" data-triboelectric="13">
          <div class="object-icon">
           üßµ
          </div>
          <div class="object-name">
           Polyester Fabric
          </div>
          <div class="object-material">
           Synthetic polyester
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="styrofoam-cup" data-triboelectric="14">
          <div class="object-icon">
           ü•§
          </div>
          <div class="object-name">
           Styrofoam Cup
          </div>
          <div class="object-material">
           Expanded polystyrene
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="plastic-wrap" data-triboelectric="15">
          <div class="object-icon">
           üì¶
          </div>
          <div class="object-name">
           Plastic Wrap
          </div>
          <div class="object-material">
           Thin plastic film
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="rubber-balloon" data-triboelectric="16">
          <div class="object-icon">
           üéà
          </div>
          <div class="object-name">
           Rubber Balloon
          </div>
          <div class="object-material">
           Latex rubber surface
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="vinyl-record" data-triboelectric="17">
          <div class="object-icon">
           üíø
          </div>
          <div class="object-name">
           Vinyl Record
          </div>
          <div class="object-material">
           PVC vinyl surface
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="rubber-shoes" data-triboelectric="18">
          <div class="object-icon">
           üëü
          </div>
          <div class="object-name">
           Rubber Shoes
          </div>
          <div class="object-material">
           Rubber sole material
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="carpet-fabric" data-triboelectric="19">
          <div class="object-icon">
           üè†
          </div>
          <div class="object-name">
           Carpet
          </div>
          <div class="object-material">
           Synthetic carpet fibers
          </div>
         </div>
         <div class="draggable-item real-object-visual" draggable="true" data-type="teflon-pan" data-triboelectric="20">
          <div class="object-icon">
           üç≥
          </div>
          <div class="object-name">
           Teflon Pan
          </div>
          <div class="object-material">
           Non-stick coating
          </div>
         </div>
        </div>
        <div class="drop-zone" id="rubbingZone">
         <div class="section-title">
          Rubbing Simulation Area
         </div>
         <div style="display: flex; gap: 1rem; margin-bottom: 1rem;"><button class="clear-area-btn" onclick="clearRubbingArea()">üóëÔ∏è Clear Area</button> <button class="clear-area-btn" onclick="autoRubTogether()" style="background: linear-gradient(145deg, #32CD32, #228B22);">‚ö° Rub Together</button>
         </div>
         <div class="triboelectric-info">
          <h4 style="color: #FFD700;">Triboelectric Series (Most + to Most -):</h4>
          <p style="color: white; font-size: 0.8rem;">Cat Fur ‚Üí Glass ‚Üí Hair ‚Üí Nylon ‚Üí Wool ‚Üí Silk ‚Üí Aluminum ‚Üí Paper ‚Üí Cotton ‚Üí Wood ‚Üí Plastic Pen ‚Üí Plastic Comb ‚Üí Polyester ‚Üí Styrofoam ‚Üí Plastic Wrap ‚Üí Rubber ‚Üí Vinyl ‚Üí Rubber Shoes ‚Üí Carpet ‚Üí Teflon</p>
          <p style="color: #87CEEB; font-size: 0.7rem; margin-top: 0.5rem;">üí° Objects higher in the series become positive (+) when rubbed with objects lower in the series</p>
         </div>
         <div id="simulationArea" style="position: relative; min-height: 400px; display: flex; flex-wrap: wrap; justify-content: center; align-items: flex-start; background: rgba(0,0,0,0.2); border-radius: 10px; border: 2px dashed #FFD700; padding: 2rem; gap: 1rem;">
          <div style="color: #FFD700; font-style: italic; font-size: 1.2rem; width: 100%; text-align: center;">
           Drop objects here to start rubbing simulation
          </div>
         </div>
         <div id="electronTransferArea" style="position: relative; min-height: 100px; margin: 1.5rem 0; padding: 1rem; background: rgba(0,0,0,0.3); border-radius: 8px; border: 1px solid #87CEEB;"></div>
         <div id="chargingResults" style="margin-top: 1.5rem; text-align: center; clear: both;"></div>
        </div>
       </div>
       <div class="explanation-panel">
        <div class="explanation-title">
         Charging by Rubbing (Triboelectric Effect)
        </div>
        <div class="explanation-text"><strong>How to Use:</strong> Drop 2+ objects into the simulation area, then either: <br>
         ‚Ä¢ <strong>Manual Rubbing:</strong> Drag objects close together (within touching distance) and keep them there for continuous rubbing <br>
         ‚Ä¢ <strong>Auto Rubbing:</strong> Click the "‚ö° Rub Together" button to automatically rub the first two available objects
        </div>
        <div class="explanation-text"><strong>Real-World Process:</strong> When you rub two different materials together, electrons transfer from one to the other. The material that loses electrons becomes positively charged, while the one that gains electrons becomes negatively charged.
        </div>
        <div class="explanation-text"><strong>Examples:</strong> Balloon on hair, socks on carpet, plastic comb through hair, rubber shoes on floor.
        </div>
        <div class="explanation-text" style="margin-top: 2rem; background: rgba(50, 205, 50, 0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #32CD32;"><strong style="color: #32CD32; font-size: 1.2rem;">üéì Student Discussion Points:</strong> <br><br><strong>1. Why do some materials become positive and others negative?</strong> <br>
         ‚Ä¢ Different materials have different "electron-holding power" (electronegativity) <br>
         ‚Ä¢ Materials higher in the triboelectric series (like cat fur, glass) lose electrons easily <br>
         ‚Ä¢ Materials lower in the series (like rubber, plastic) gain electrons easily <br>
         ‚Ä¢ Think of it like a "tug of war" - the stronger material wins the electrons! <br><br><strong>2. What happens to the electrons during rubbing?</strong> <br>
         ‚Ä¢ Electrons don't disappear - they just move from one object to another <br>
         ‚Ä¢ The total charge in the system stays the same (conservation of charge) <br>
         ‚Ä¢ If one object gains 100 electrons, the other loses exactly 100 electrons <br>
         ‚Ä¢ This is why charges are always equal and opposite (+Q and -Q) <br><br><strong>3. Why does rubbing create more charge than just touching?</strong> <br>
         ‚Ä¢ Rubbing creates friction and heat, which gives electrons energy to move <br>
         ‚Ä¢ More surface contact means more electron transfer opportunities <br>
         ‚Ä¢ Repeated rubbing builds up more and more charge over time <br>
         ‚Ä¢ Fresh surfaces are exposed during rubbing, allowing more electron transfer <br><br><strong>4. Real-life applications you experience daily:</strong> <br>
         ‚Ä¢ <strong>Clothes dryer static:</strong> Synthetic fabrics rub together, creating charge <br>
         ‚Ä¢ <strong>Walking on carpet:</strong> Your socks rub against carpet fibers <br>
         ‚Ä¢ <strong>Combing dry hair:</strong> Plastic comb pulls electrons from hair <br>
         ‚Ä¢ <strong>Removing plastic wrap:</strong> Plastic rubs against itself and other surfaces <br>
         ‚Ä¢ <strong>Car door shock:</strong> Clothes rub against car seat while getting out
        </div>
        <div class="explanation-text" style="margin-top: 1.5rem; background: rgba(255, 215, 0, 0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #FFD700;"><strong style="color: #FFD700; font-size: 1.2rem;">üî¨ Try This Experiment at Home:</strong> <br><br><strong>Balloon and Hair Experiment:</strong> <br>
         1. Rub a balloon on your hair for 30 seconds <br>
         2. Slowly pull the balloon away - watch your hair follow it! <br>
         3. Try picking up small pieces of paper with the charged balloon <br>
         4. Touch the balloon to a metal doorknob - you'll see a small spark! <br><br><strong>What's happening?</strong> <br>
         ‚Ä¢ Balloon steals electrons from your hair (balloon becomes negative -) <br>
         ‚Ä¢ Your hair loses electrons (hair becomes positive +) <br>
         ‚Ä¢ Opposite charges attract - hair follows balloon <br>
         ‚Ä¢ Neutral paper gets polarized and sticks to charged balloon <br>
         ‚Ä¢ Metal doorknob provides path for electrons to flow back (spark!)
        </div>
       </div>
      </div><!-- Charging by Conduction Section -->
      <div class="charging-method-section" id="conduction" style="display: none;">
       <div class="drag-drop-container">
        <div class="drag-items">
         <div class="section-title">
          Charged Objects
         </div>
         <div class="draggable-item" draggable="true" data-type="charged-rod-positive" data-charge="positive">
          ‚ö° Charged Glass Rod (+)
         </div>
         <div class="draggable-item" draggable="true" data-type="charged-rod-negative" data-charge="negative">
          ‚ö° Charged Plastic Rod (-)
         </div>
         <div class="draggable-item" draggable="true" data-type="van-de-graaff" data-charge="positive">
          üîÆ Van de Graaff Generator
         </div>
         <div class="draggable-item" draggable="true" data-type="charged-balloon" data-charge="negative">
          üéà Charged Balloon (-)
         </div>
         <div class="draggable-item" draggable="true" data-type="charged-comb" data-charge="negative">
          üíá Charged Comb (-)
         </div>
         <div class="draggable-item" draggable="true" data-type="charged-socks" data-charge="negative">
          üß¶ Charged Socks (-)
         </div>
         <div class="draggable-item" draggable="true" data-type="charged-sweater" data-charge="positive">
          üß• Charged Sweater (+)
         </div>
         <div class="draggable-item" draggable="true" data-type="lightning-cloud" data-charge="negative">
          ‚õàÔ∏è Storm Cloud (-)
         </div>
         <div class="section-title" style="margin-top: 1rem;">
          Neutral Conductors
         </div>
         <div class="draggable-item" draggable="true" data-type="human-hand" data-charge="neutral">
          ‚úã Human Hand
         </div>
         <div class="draggable-item" draggable="true" data-type="metal-sphere" data-charge="neutral">
          ‚ö™ Metal Sphere
         </div>
         <div class="draggable-item" draggable="true" data-type="copper-wire" data-charge="neutral">
          üî∂ Copper Wire
         </div>
         <div class="draggable-item" draggable="true" data-type="aluminum-foil" data-charge="neutral">
          üìÑ Aluminum Foil
         </div>
         <div class="draggable-item" draggable="true" data-type="metal-spoon" data-charge="neutral">
          ü•Ñ Metal Spoon
         </div>
         <div class="draggable-item" draggable="true" data-type="coin" data-charge="neutral">
          ü™ô Coin
         </div>
         <div class="draggable-item" draggable="true" data-type="car-body" data-charge="neutral">
          üöó Car Body
         </div>
         <div class="draggable-item" draggable="true" data-type="metal-doorknob" data-charge="neutral">
          üö™ Metal Doorknob
         </div>
         <div class="draggable-item" draggable="true" data-type="water-faucet" data-charge="neutral">
          üö∞ Water Faucet
         </div>
         <div class="draggable-item" draggable="true" data-type="metal-chair" data-charge="neutral">
          ü™ë Metal Chair
         </div>
         <div class="draggable-item" draggable="true" data-type="electroscope" data-charge="neutral">
          üìè Electroscope
         </div>
         <div class="draggable-item" draggable="true" data-type="person-body" data-charge="neutral">
          üßç Person
         </div>
        </div>
        <div class="drop-zone" id="conductionZone">
         <div class="section-title">
          Conduction Simulation Area
         </div>
         <div style="display: flex; gap: 1rem; margin-bottom: 1rem;"><button class="clear-area-btn" onclick="clearConductionArea()">üóëÔ∏è Clear Area</button> <button class="clear-area-btn" onclick="autoTouchObjects()" style="background: linear-gradient(145deg, #32CD32, #228B22);">‚ö° Touch Objects</button>
         </div>
         <div id="conductionSimulationArea" style="position: relative; min-height: 400px; display: flex; flex-wrap: wrap; justify-content: center; align-items: flex-start; background: rgba(0,0,0,0.2); border-radius: 10px; border: 2px dashed #FFD700; padding: 2rem; gap: 1rem;">
          <div style="color: #FFD700; font-style: italic; font-size: 1.2rem; width: 100%; text-align: center;">
           Drop objects here, then touch charged to neutral objects!
          </div>
         </div>
         <div id="conductionResults" style="margin-top: 1.5rem; text-align: center; clear: both;"></div><!-- Educational Discussion Content -->
         <div style="margin-top: 2rem; background: rgba(0, 0, 0, 0.8); padding: 2rem; border-radius: 15px; border: 3px solid #87CEEB; box-shadow: 0 0 20px rgba(135, 206, 235, 0.3);"><strong style="color: #87CEEB; font-size: 1.8rem; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);">üéì Student Discussion Points:</strong> <br><br><strong style="color: #FFD700; font-size: 1.3rem;">1. Why do electrons flow during conduction?</strong> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Electrons always try to spread out evenly (like water finding its level)</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ When objects touch, electrons can move freely through conductors</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ They flow until both objects have the same "electric potential"</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Think of it like air pressure equalizing when you open a door!</span> <br><br><strong style="color: #FFD700; font-size: 1.3rem;">2. What makes a good conductor vs. insulator?</strong> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ <strong style="color: #32CD32;">Conductors:</strong> Have "free electrons" that can move easily (metals, salt water, human body)</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ <strong style="color: #FF6B6B;">Insulators:</strong> Hold their electrons tightly (rubber, plastic, glass, dry air)</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ <strong style="color: #FFA500;">Semiconductors:</strong> In between - can conduct under certain conditions (silicon, germanium)</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Temperature and moisture can change conductivity!</span> <br><br><strong style="color: #FFD700; font-size: 1.3rem;">3. Why do you get shocked by doorknobs but not wooden doors?</strong> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Metal doorknobs are excellent conductors - electrons flow quickly (SHOCK!)</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Wood is an insulator - electrons can't flow easily (no shock)</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ The faster the electron flow, the more you feel it</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Humid air conducts better than dry air - fewer shocks on humid days!</span> <br><br><strong style="color: #FFD700; font-size: 1.3rem;">4. Safety applications in real life:</strong> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ <strong style="color: #32CD32;">Lightning rods:</strong> Conduct lightning safely to ground</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ <strong style="color: #32CD32;">Grounding wires:</strong> Prevent dangerous charge buildup in appliances</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ <strong style="color: #32CD32;">Anti-static wrist straps:</strong> Protect computer components during repair</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ <strong style="color: #32CD32;">Airplane fuel trucks:</strong> Grounded to prevent static sparks near fuel</span>
         </div>
         <div style="margin-top: 1.5rem; background: rgba(0, 0, 0, 0.8); padding: 2rem; border-radius: 15px; border: 3px solid #FF6B6B; box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);"><strong style="color: #FF6B6B; font-size: 1.8rem; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);">‚ö° Van de Graaff Generator Demonstration:</strong> <br><br><!-- Interactive Van de Graaff Simulation -->
          <div style="background: rgba(255, 215, 0, 0.1); border-radius: 15px; padding: 2rem; margin: 1.5rem 0; border: 2px solid #FFD700;">
           <h4 style="color: #FFD700; text-align: center; margin-bottom: 1.5rem;">üîÆ Interactive Van de Graaff Simulation</h4>
           <div style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 2rem;"><button class="demo-btn" onclick="startVanDeGraaffDemo()" style="background: linear-gradient(145deg, #FFD700, #FFA500);">‚ö° Start Generator</button> <button class="demo-btn" onclick="touchVanDeGraaffDome()" style="background: linear-gradient(145deg, #32CD32, #228B22);">‚úã Touch Dome</button> <button class="demo-btn" onclick="resetVanDeGraaffDemo()" style="background: linear-gradient(145deg, #FF6B6B, #DC143C);">üîÑ Reset</button>
           </div>
           <div id="vanDeGraaffSimulation" style="position: relative; height: 400px; background: linear-gradient(135deg, rgba(0,0,50,0.3), rgba(0,0,100,0.3)); border-radius: 15px; border: 2px solid #87CEEB; overflow: hidden;"><!-- Van de Graaff Generator Structure -->
            <div id="vanDeGraaffBase" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 80px; height: 120px; background: linear-gradient(145deg, #8B4513, #654321); border-radius: 10px; border: 2px solid #A0522D;">
             <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #FFD700; font-size: 0.8rem; font-weight: bold; text-align: center;">
              Motor<br>
              Base
             </div>
            </div><!-- Metal Dome -->
            <div id="vanDeGraaffDome" style="position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%); width: 120px; height: 120px; background: radial-gradient(circle, #C0C0C0, #808080); border-radius: 50%; border: 3px solid #A9A9A9; cursor: pointer; transition: all 0.3s ease;">
             <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #000; font-weight: bold; text-align: center; font-size: 0.9rem;">
              Metal<br>
              Dome
             </div>
             <div id="domeChargeIndicator" style="position: absolute; top: -15px; right: -15px; width: 30px; height: 30px; background: radial-gradient(circle, #FF6B6B, #DC143C); border-radius: 50%; display: none; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 1.2rem; animation: chargeGlow 1.5s ease-in-out infinite;">
              +
             </div>
            </div><!-- Person Figure -->
            <div id="personFigure" style="position: absolute; bottom: 20px; right: 100px; width: 60px; height: 180px; display: none;"><!-- Head -->
             <div id="personHead" style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 40px; height: 40px; background: radial-gradient(circle, #FDBCB4, #E8A598); border-radius: 50%; border: 2px solid #D4A574;">
              <div style="position: absolute; top: 8px; left: 12px; width: 4px; height: 4px; background: #000; border-radius: 50%;"></div>
              <div style="position: absolute; top: 8px; right: 12px; width: 4px; height: 4px; background: #000; border-radius: 50%;"></div>
              <div style="position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); width: 8px; height: 2px; background: #000; border-radius: 2px;"></div>
             </div><!-- Hair Strands -->
             <div id="hairContainer" style="position: absolute; top: -5px; left: 50%; transform: translateX(-50%); width: 50px; height: 50px;">
              <div class="hair-strand" data-strand="1" style="position: absolute; top: 5px; left: 10px; width: 2px; height: 15px; background: #8B4513; border-radius: 1px; transform-origin: bottom; transition: all 0.8s ease;"></div>
              <div class="hair-strand" data-strand="2" style="position: absolute; top: 2px; left: 15px; width: 2px; height: 18px; background: #8B4513; border-radius: 1px; transform-origin: bottom; transition: all 0.8s ease;"></div>
              <div class="hair-strand" data-strand="3" style="position: absolute; top: 0px; left: 20px; width: 2px; height: 20px; background: #8B4513; border-radius: 1px; transform-origin: bottom; transition: all 0.8s ease;"></div>
              <div class="hair-strand" data-strand="4" style="position: absolute; top: 0px; left: 25px; width: 2px; height: 20px; background: #8B4513; border-radius: 1px; transform-origin: bottom; transition: all 0.8s ease;"></div>
              <div class="hair-strand" data-strand="5" style="position: absolute; top: 2px; left: 30px; width: 2px; height: 18px; background: #8B4513; border-radius: 1px; transform-origin: bottom; transition: all 0.8s ease;"></div>
              <div class="hair-strand" data-strand="6" style="position: absolute; top: 5px; left: 35px; width: 2px; height: 15px; background: #8B4513; border-radius: 1px; transform-origin: bottom; transition: all 0.8s ease;"></div>
             </div><!-- Body -->
             <div style="position: absolute; top: 40px; left: 50%; transform: translateX(-50%); width: 30px; height: 80px; background: linear-gradient(145deg, #4169E1, #0000CD); border-radius: 15px;"></div><!-- Arms -->
             <div id="leftArm" style="position: absolute; top: 50px; left: 5px; width: 15px; height: 40px; background: #FDBCB4; border-radius: 8px; transform-origin: top; transition: all 0.5s ease;"></div>
             <div id="rightArm" style="position: absolute; top: 50px; right: 5px; width: 15px; height: 40px; background: #FDBCB4; border-radius: 8px; transform-origin: top; transition: all 0.5s ease;"></div><!-- Legs -->
             <div style="position: absolute; bottom: 0; left: 15px; width: 12px; height: 60px; background: #000080; border-radius: 6px;"></div>
             <div style="position: absolute; bottom: 0; right: 15px; width: 12px; height: 60px; background: #000080; border-radius: 6px;"></div><!-- Charge Indicator -->
             <div id="personChargeIndicator" style="position: absolute; top: -20px; right: -20px; width: 25px; height: 25px; background: radial-gradient(circle, #FF6B6B, #DC143C); border-radius: 50%; display: none; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 1rem; animation: chargeGlow 1.5s ease-in-out infinite;">
              +
             </div>
            </div><!-- Charge Flow Animation Container -->
            <div id="chargeFlowContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></div><!-- Status Display -->
            <div id="vanDeGraaffStatus" style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 1rem; border-radius: 8px; border: 1px solid #FFD700; max-width: 200px;">
             <div style="color: #FFD700; font-weight: bold; margin-bottom: 0.5rem;">
              Generator Status:
             </div>
             <div id="statusText" style="color: #FFFFFF; font-size: 0.9rem;">
              Ready to start
             </div>
            </div>
           </div>
           <div style="margin-top: 1rem; text-align: center; color: #87CEEB; font-size: 0.9rem; font-style: italic;">
            Click "Start Generator" to build up charge, then "Touch Dome" to see what happens!
           </div>
          </div><strong style="color: #FFD700; font-size: 1.3rem;">What happens when you touch the dome?</strong> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">1. The dome has a strong positive charge built up</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">2. When you touch it, electrons flow from your body to the dome</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">3. Your whole body becomes positively charged (same as the dome)</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">4. Your hair strands repel each other because they all have the same charge!</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">5. If someone else touches you, electrons flow between you both - ZAP!</span> <br><br><strong style="color: #FFD700; font-size: 1.3rem;">Why does your hair stand up?</strong> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Each hair becomes positively charged</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Like charges repel - each hair pushes away from the others</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ Your hair tries to get as far away from other hairs as possible</span> <br><span style="color: #FFFFFF; font-size: 1.1rem; line-height: 1.6;">‚Ä¢ The result: hair standing straight up like you're scared! üò±</span> <br><br><strong style="color: #32CD32; font-size: 1.2rem;">Safety note:</strong> <span style="color: #FFFFFF; font-size: 1.1rem;">Van de Graaff generators in schools use low current - they're safe but can be startling!</span>
         </div>
        </div>
       </div>
       <div class="explanation-panel">
        <div class="explanation-title">
         Charging by Conduction (Direct Contact)
        </div>
        <div class="explanation-text"><strong>Real-World Process:</strong> When a charged object touches a neutral conductor, electrons flow through the contact point until both objects have the same type of charge.
        </div>
        <div class="explanation-text"><strong>Common Examples:</strong> <br>
         ‚Ä¢ <strong>Static Shock:</strong> Your charged body touches a metal doorknob - electrons jump between you and the metal <br>
         ‚Ä¢ <strong>Van de Graaff Generator:</strong> Touching the dome transfers charge to your body, making your hair stand up <br>
         ‚Ä¢ <strong>Lightning Strike:</strong> Charged storm clouds conduct electricity through metal objects like lightning rods <br>
         ‚Ä¢ <strong>Balloon on Hand:</strong> A charged balloon touching your hand transfers electrons through your conductive body <br>
         ‚Ä¢ <strong>Car Static:</strong> Getting out of a car builds up charge that discharges when you touch the metal door
        </div>
        <div class="explanation-text"><strong>Why Humans Conduct:</strong> The human body contains water and salts, making it a good conductor. That's why you can get static shocks and why touching a Van de Graaff generator affects your whole body!
        </div>
       </div>
      </div><!-- Charging by Induction Section -->
      <div class="charging-method-section" id="induction" style="display: none;">
       <div class="drag-drop-container">
        <div class="drag-items">
         <div class="section-title">
          Real Induction Objects
         </div>
         <div class="draggable-item" draggable="true" data-type="charged-rod-approach" data-charge="+">
          ‚ö° Charged Rod (Approach)
         </div>
         <div class="draggable-item" draggable="true" data-type="neutral-conductor-sphere" data-charge="0">
          ‚ö™ Neutral Conductor
         </div>
         <div class="draggable-item" draggable="true" data-type="ground-connection" data-charge="0">
          üåç Ground Wire
         </div>
         <div class="draggable-item" draggable="true" data-type="electroscope-leaves" data-charge="0">
          üìè Electroscope
         </div>
         <div class="draggable-item" draggable="true" data-type="metal-can" data-charge="0">
          ü•´ Metal Can
         </div>
         <div class="draggable-item" draggable="true" data-type="pith-ball" data-charge="0">
          ‚ö´ Pith Ball
         </div>
         <div class="draggable-item" draggable="true" data-type="water-stream" data-charge="0">
          üíß Water Stream
         </div>
         <div class="draggable-item" draggable="true" data-type="remove-ground" data-charge="0">
          üîå Remove Ground
         </div>
        </div>
        <div class="drop-zone" id="inductionZone">
         <div class="section-title">
          Induction Simulation Area
         </div><button class="clear-area-btn" onclick="clearInductionArea()">üóëÔ∏è Clear Area</button>
         <div class="charging-result" id="inductionResult">
          <div style="text-align: center; color: #FFD700; margin: 1rem 0;">
           Bring charged object near neutral conductor (no touching!)
          </div>
          <div id="fieldViz" style="position: relative; height: 120px; background: rgba(0,0,0,0.2); border-radius: 8px; overflow: hidden;">
           <div class="field-lines"></div>
          </div>
         </div>
        </div>
       </div>
       <div class="explanation-panel">
        <div class="explanation-title">
         Charging by Induction (No Contact)
        </div>
        <div class="explanation-text"><strong>Real-World Process:</strong> A charged object creates an electric field that causes charge separation in nearby conductors without direct contact. Grounding allows excess charge to flow away.
        </div>
        <div class="explanation-text"><strong>Examples:</strong> Lightning rods, Van de Graaff generators, electrostatic painting, photocopier drums.
        </div>
       </div>
      </div>
     </div><!-- Induction & Polarization Simulation -->
     <div class="competency-section" id="induction" style="display: none;">
      <div class="drag-drop-container">
       <div class="drag-items">
        <div class="section-title">
         Charging &amp; Polarization Tools
        </div>
        <div class="draggable-item" draggable="true" data-type="charged-rod">
         Charged Rod
        </div>
        <div class="draggable-item" draggable="true" data-type="neutral-conductor">
         Neutral Conductor
        </div>
        <div class="draggable-item" draggable="true" data-type="ground-wire">
         Ground Wire
        </div>
        <div class="draggable-item" draggable="true" data-type="water-molecule">
         Water Molecule (H‚ÇÇO)
        </div>
        <div class="draggable-item" draggable="true" data-type="paper-bits">
         Paper Bits
        </div>
        <div class="draggable-item" draggable="true" data-type="electroscope">
         Electroscope
        </div>
       </div>
       <div class="drop-zone" id="inductionZone">
        <div class="section-title">
         Induction &amp; Polarization Area
        </div>
        <div class="induction-display" id="inductionDisplay">
         <div class="field-lines"></div>
        </div>
       </div>
      </div>
      <div class="explanation-panel">
       <div class="explanation-title">
        Charging by Induction &amp; Polarization
       </div>
       <div class="explanation-text"><strong>Competencies 9-13:</strong> Induction occurs when a charged object causes charge redistribution in a nearby conductor without direct contact. Polarization creates temporary dipoles in neutral molecules when exposed to electric fields.
       </div>
       <div class="explanation-text"><strong>Real-world applications:</strong> Van de Graaff generators, lightning rods, electrostatic painting, water purification systems, and the attraction of dust to TV screens.
       </div>
      </div>
     </div><!-- Calculations Simulation -->
     <div class="competency-section" id="calculations" style="display: none;">
      <div class="calculation-container">
       <div class="calc-section">
        <div class="section-title">
         Charge Calculation Problems
        </div>
        <div class="problem-box">
         <h4 style="color: #FFD700;">Problem 1: Atomic Charge</h4>
         <p style="color: white;">An atom has 6 protons and 8 electrons. Calculate its net charge.</p>
         <div class="calc-input"><input type="number" id="prob1" placeholder="Enter charge in C (use scientific notation)"> <button onclick="checkAnswer(1, -3.2e-19)">Check Answer</button>
         </div>
         <div class="answer-feedback" id="feedback1"></div>
        </div>
        <div class="problem-box">
         <h4 style="color: #FFD700;">Problem 2: Ion Formation</h4>
         <p style="color: white;">How many electrons must be removed from a neutral atom to create a +2 charge?</p>
         <div class="calc-input"><input type="number" id="prob2" placeholder="Number of electrons"> <button onclick="checkAnswer(2, 2)">Check Answer</button>
         </div>
         <div class="answer-feedback" id="feedback2"></div>
        </div>
        <div class="problem-box">
         <h4 style="color: #FFD700;">Problem 3: Charge Transfer</h4>
         <p style="color: white;">If 1.0√ó10¬π¬≤ electrons are transferred, what is the charge transferred?</p>
         <div class="calc-input"><input type="number" id="prob3" placeholder="Enter charge in C"> <button onclick="checkAnswer(3, -1.6e-7)">Check Answer</button>
         </div>
         <div class="answer-feedback" id="feedback3"></div>
        </div>
       </div>
       <div class="formula-reference">
        <div class="section-title">
         Key Formulas
        </div>
        <div class="formula-box">
         <p><strong>Elementary Charge:</strong> e = 1.6 √ó 10‚Åª¬π‚Åπ C</p>
         <p><strong>Net Charge:</strong> Q = (# protons - # electrons) √ó e</p>
         <p><strong>Charge Transfer:</strong> Q = n √ó e</p>
         <p><strong>Where:</strong> n = number of electrons transferred</p>
        </div>
       </div>
      </div>
      <div class="explanation-panel">
       <div class="explanation-title">
        Charge Calculations
       </div>
       <div class="explanation-text"><strong>Competency 5:</strong> Electric charge is quantized in units of elementary charge (e = 1.6√ó10‚Åª¬π‚Åπ C). All charges are integer multiples of this fundamental unit.
       </div>
       <div class="explanation-text"><strong>Real-world application:</strong> These calculations are essential in designing electronic circuits, calculating current flow in batteries, and understanding ion concentrations in biological systems.
       </div>
      </div>
     </div>
    </div><!-- Quiz Section -->
    <div class="quiz-container" id="quizArea">
     <div class="simulation-header"><button class="back-button" onclick="showMainMenu()">‚Üê Back to Menu</button>
      <h2 class="simulation-title">Physics Quiz Challenge</h2>
     </div>
     <div class="quiz-navigation"><button class="quiz-nav-btn active" onclick="showQuizSection('multiple-choice')">Multiple Choice (10)</button> <button class="quiz-nav-btn" onclick="showQuizSection('true-false')">True or False (10)</button>
      <div class="quiz-score" id="quizScore">
       Score: 0/20
      </div>
     </div><!-- Multiple Choice Questions -->
     <div class="quiz-section" id="multiple-choice">
      <div class="quiz-question">
       <div class="question-text">
        1. What happens when two positive charges are brought close together?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         They attract each other
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         They repel each other
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         They cancel each other out
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Nothing happens
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        2. Which material is the best conductor of electricity?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Rubber
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         Copper
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Glass
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Plastic
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        3. What is the unit of electric current?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Volt
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         Ampere
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Ohm
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Watt
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        4. According to Ohm's Law, V = I √ó R. What does R represent?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Current
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Voltage
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         Resistance
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Power
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        5. What type of current flows in one direction only?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Alternating Current (AC)
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         Direct Current (DC)
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Static Current
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Variable Current
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        6. What device is used to measure electric current?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Voltmeter
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         Ammeter
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Ohmmeter
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Wattmeter
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        7. In a parallel circuit, what happens to the total resistance?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         It increases
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         It decreases
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         It stays the same
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         It becomes zero
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        8. What is the electric field strength measured in?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Volts
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         Volts per meter (V/m)
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Amperes
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Coulombs
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        9. What happens to the electric field inside a conductor in electrostatic equilibrium?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         It becomes very strong
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         It fluctuates randomly
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         It becomes zero
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         It reverses direction
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        10. What is the capacitance of a capacitor measured in?
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Volts
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Amperes
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'mc')">
         Farads
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'mc')">
         Henries
        </div>
       </div>
      </div>
     </div><!-- True or False Questions -->
     <div class="quiz-section" id="true-false" style="display: none;">
      <div class="quiz-question">
       <div class="question-text">
        1. Like charges attract each other.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        2. Electric current is the flow of electrons through a conductor.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        3. Voltage is measured in amperes.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        4. In a series circuit, the current is the same through all components.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        5. Insulators have free electrons that can move easily.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        6. Electric field lines always point from positive to negative charges.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        7. Power is calculated by multiplying voltage and current (P = V √ó I).
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        8. Capacitors store magnetic energy.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        9. The electric potential difference is another term for voltage.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         False
        </div>
       </div>
      </div>
      <div class="quiz-question">
       <div class="question-text">
        10. Grounding provides a path for excess electric charge to flow safely to the earth.
       </div>
       <div class="quiz-options">
        <div class="quiz-option" onclick="selectAnswer(this, false, 'tf')">
         True
        </div>
        <div class="quiz-option" onclick="selectAnswer(this, true, 'tf')">
         False
        </div>
       </div>
      </div>
     </div>
    </div>
   </main>
   <footer class="footer">
    <div class="school-info">
     <div id="schoolName">
      Sumulong Memorial High School
     </div>
     <div id="schoolLocation">
      Antipolo City
     </div>
    </div>
   </footer>
  </div>
  <script>
        // Configuration object for editable features
        const defaultConfig = {
            main_title: "General Physics 2 Simulation Laboratory",
            school_name: "Sumulong Memorial High School",
            school_location: "Antipolo City"
        };

        let config = { ...defaultConfig };

        // Initialize Element SDK
        if (window.elementSdk) {
            window.elementSdk.init({
                defaultConfig: defaultConfig,
                onConfigChange: async (newConfig) => {
                    config = { ...config, ...newConfig };
                    
                    // Update UI elements based on config
                    const mainTitle = document.getElementById('mainTitle');
                    const schoolName = document.getElementById('schoolName');
                    const schoolLocation = document.getElementById('schoolLocation');
                    
                    if (mainTitle) mainTitle.textContent = config.main_title || defaultConfig.main_title;
                    if (schoolName) schoolName.textContent = config.school_name || defaultConfig.school_name;
                    if (schoolLocation) schoolLocation.textContent = config.school_location || defaultConfig.school_location;
                },
                mapToCapabilities: (config) => ({
                    recolorables: [],
                    borderables: [],
                    fontEditable: undefined,
                    fontSizeable: undefined
                }),
                mapToEditPanelValues: (config) => new Map([
                    ["main_title", config.main_title || defaultConfig.main_title],
                    ["school_name", config.school_name || defaultConfig.school_name],
                    ["school_location", config.school_location || defaultConfig.school_location]
                ])
            });
        }

        // Create animated electricity effects
        function createElectricityEffects() {
            const container = document.getElementById('electricityContainer');
            
            // Create lightning bolts
            for (let i = 0; i < 5; i++) {
                const lightning = document.createElement('div');
                lightning.className = 'lightning';
                lightning.style.left = Math.random() * 100 + '%';
                lightning.style.height = Math.random() * 200 + 100 + 'px';
                lightning.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(lightning);
            }
            
            // Create sparks
            for (let i = 0; i < 15; i++) {
                const spark = document.createElement('div');
                try { soundManager.playSpark(); } catch(e){}
                // Remove spark after animation
                spark.style.left = Math.random() * 100 + '%';
                spark.style.top = Math.random() * 100 + '%';
                spark.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(spark);
            }
        }

        // Navigation functions
        function showMainMenu() {
            document.getElementById('mainMenu').style.display = 'grid';
            document.getElementById('module1Area').style.display = 'none';
            document.getElementById('quizArea').style.display = 'none';
        }

        function showModule1() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('module1Area').style.display = 'block';
            document.getElementById('quizArea').style.display = 'none';
        }

        function showRealWorld() {
            // Create a simple real-world application display
            const mainMenu = document.getElementById('mainMenu');
            mainMenu.innerHTML = `
                <div style="grid-column: 1 / -1; background: rgba(0,0,0,0.6); border-radius: 15px; padding: 2rem; border: 2px solid #FFD700;">
                    <button class="back-button" onclick="location.reload()" style="margin-bottom: 1rem;">‚Üê Back to Menu</button>
                    <h2 style="color: #FFD700; text-align: center; margin-bottom: 2rem;">Real World Applications</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem;">
                        <div style="background: rgba(255,215,0,0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #FFD700;">
                            <h3 style="color: #FFD700;">‚ö° Electric Vehicles</h3>
                            <p style="color: white;">Electric cars use the principles of electromagnetism and electric circuits to convert stored electrical energy into motion.</p>
                        </div>
                        <div style="background: rgba(255,215,0,0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #FFD700;">
                            <h3 style="color: #FFD700;">üì± Smartphones</h3>
                            <p style="color: white;">Capacitive touchscreens work by detecting changes in electric fields when your finger approaches the screen.</p>
                        </div>
                        <div style="background: rgba(255,215,0,0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #FFD700;">
                            <h3 style="color: #FFD700;">‚ö° Power Grids</h3>
                            <p style="color: white;">Electrical power distribution systems use transformers and transmission lines based on electromagnetic principles.</p>
                        </div>
                        <div style="background: rgba(255,215,0,0.1); padding: 1.5rem; border-radius: 10px; border: 1px solid #FFD700;">
                            <h3 style="color: #FFD700;">üè• Medical Devices</h3>
                            <p style="color: white;">MRI machines, defibrillators, and X-ray equipment all rely on electromagnetic principles to function.</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function showDiscussion() {
            const mainMenu = document.getElementById('mainMenu');
            mainMenu.innerHTML = `
                <div style="grid-column: 1 / -1; background: rgba(0,0,0,0.6); border-radius: 15px; padding: 2rem; border: 2px solid #FFD700;">
                    <button class="back-button" onclick="location.reload()" style="margin-bottom: 1rem;">‚Üê Back to Menu</button>
                    <h2 style="color: #FFD700; text-align: center; margin-bottom: 2rem;">Discussion Hub</h2>
                    <div style="display: grid; gap: 1.5rem;">
                        <div style="background: rgba(220,20,60,0.2); padding: 1.5rem; border-radius: 10px; border: 1px solid #DC143C;">
                            <h3 style="color: #FFD700;">üí° Think & Share</h3>
                            <p style="color: white; margin-bottom: 1rem;">How do you think electric fields might be used in future technology?</p>
                            <textarea style="width: 100%; height: 80px; background: rgba(0,0,0,0.5); border: 1px solid #FFD700; border-radius: 5px; color: white; padding: 0.5rem;" placeholder="Share your thoughts..."></textarea>
                        </div>
                        <div style="background: rgba(220,20,60,0.2); padding: 1.5rem; border-radius: 10px; border: 1px solid #DC143C;">
                            <h3 style="color: #FFD700;">üî¨ Experiment Ideas</h3>
                            <p style="color: white;">Brainstorm simple experiments you could do at home to demonstrate electric fields or static electricity.</p>
                            <ul style="color: #FFD700; margin-top: 1rem;">
                                <li>Balloon and hair static experiment</li>
                                <li>Salt water conductivity test</li>
                                <li>Paper and comb attraction demo</li>
                            </ul>
                        </div>
                        <div style="background: rgba(220,20,60,0.2); padding: 1.5rem; border-radius: 10px; border: 1px solid #DC143C;">
                            <h3 style="color: #FFD700;">üåü Creative Challenge</h3>
                            <p style="color: white;">Design a superhero whose powers are based on electromagnetic principles. What would their abilities be?</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function showQuiz() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('module1Area').style.display = 'none';
            document.getElementById('quizArea').style.display = 'block';
        }

        // Quiz functionality
        let quizScore = 0;
        let totalQuestions = 20;
        let answeredQuestions = new Set();

        function selectAnswer(element, isCorrect, quizType) {
            const questionElement = element.closest('.quiz-question');
            const questionIndex = Array.from(questionElement.parentNode.children).indexOf(questionElement);
            const questionId = `${quizType}-${questionIndex}`;
            
            // Prevent answering the same question multiple times
            if (answeredQuestions.has(questionId)) {
                return;
            }
            
            const options = element.parentNode.querySelectorAll('.quiz-option');
            options.forEach(option => {
                option.style.pointerEvents = 'none';
                if (option === element) {
                    option.classList.add(isCorrect ? 'correct' : 'incorrect');
                    if (isCorrect) {
                        quizScore++;
                        // Add celebration animation for correct answers
                        option.style.animation = 'celebration 0.6s ease-out';
                    }
                } else if (option.onclick.toString().includes('true')) {
                    option.classList.add('correct');
                }
            });
            
            answeredQuestions.add(questionId);
            updateQuizScore();
        }

        function updateQuizScore() {
            const scoreElement = document.getElementById('quizScore');
            scoreElement.textContent = `Score: ${quizScore}/${totalQuestions}`;
            
            // Add color coding based on score percentage
            const percentage = (quizScore / answeredQuestions.size) * 100;
            if (percentage >= 80) {
                scoreElement.style.color = '#32CD32';
            } else if (percentage >= 60) {
                scoreElement.style.color = '#FFD700';
            } else {
                scoreElement.style.color = '#FF6B6B';
            }
        }

        function showQuizSection(sectionId) {
            // Hide all quiz sections
            document.getElementById('multiple-choice').style.display = 'none';
            document.getElementById('true-false').style.display = 'none';
            
            // Show selected section
            document.getElementById(sectionId).style.display = 'block';
            
            // Update navigation buttons
            const navButtons = document.querySelectorAll('.quiz-nav-btn');
            navButtons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // Competency navigation
        function showCompetency(competencyId) {
            // Hide all competency sections
            const sections = document.querySelectorAll('.competency-section');
            sections.forEach(section => section.style.display = 'none');
            
            // Show selected section
            document.getElementById(competencyId).style.display = 'block';
            
            // Update navigation buttons
            const navButtons = document.querySelectorAll('.competency-btn');
            navButtons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Reinitialize drag and drop for the new section
            setTimeout(() => {
                setupDragAndDrop();
            }, 100);
        }

        // Calculation functionality
        function checkAnswer(problemNum, correctAnswer) {
            const input = document.getElementById(`prob${problemNum}`);
            const feedback = document.getElementById(`feedback${problemNum}`);
            const userAnswer = parseFloat(input.value);
            
            const tolerance = Math.abs(correctAnswer) * 0.01; // 1% tolerance
            const isCorrect = Math.abs(userAnswer - correctAnswer) <= tolerance;
            
            if (isCorrect) {
                feedback.textContent = '‚úì Correct! Great job!';
                feedback.className = 'answer-feedback correct';
                input.style.borderColor = '#32CD32';
            } else {
                feedback.textContent = `‚úó Incorrect. The correct answer is ${correctAnswer.toExponential(2)} C`;
                feedback.className = 'answer-feedback incorrect';
                input.style.borderColor = '#FF6B6B';
            }
        }

        // Interactive Charge Demonstration Functions
        function demonstrateRepulsion(chargeType) {
            const demoArea = document.getElementById('repulsionDemo');
            
            // Clear previous demonstration
            demoArea.innerHTML = '';
            
            // Create two particles of the same charge
            const particle1 = document.createElement('div');
            const particle2 = document.createElement('div');
            
            particle1.className = `charge-particle ${chargeType}`;
            particle2.className = `charge-particle ${chargeType}`;
            
            if (chargeType === 'positive') {
                particle1.innerHTML = '+';
                particle2.innerHTML = '+';
                particle1.style.left = '60px';
                particle2.style.left = '120px';
            } else {
                particle1.innerHTML = '-';
                particle2.innerHTML = '-';
                particle1.style.left = '60px';
                particle2.style.left = '120px';
            }
            
            particle1.style.top = '80px';
            particle2.style.top = '80px';
            
            // Add repulsion animation
            particle1.style.setProperty('--repel-distance', '-40px');
            particle2.style.setProperty('--repel-distance', '40px');
            
            setTimeout(() => {
                particle1.classList.add('repelling');
                particle2.classList.add('repelling');
            }, 500);
            
            // Create force lines showing repulsion
            const forceLine = document.createElement('div');
            forceLine.className = 'force-line repulsion';
            forceLine.style.left = '80px';
            forceLine.style.top = '98px';
            forceLine.style.width = '80px';
            
            demoArea.appendChild(particle1);
            demoArea.appendChild(particle2);
            demoArea.appendChild(forceLine);
            
            // Add explanation text
            const explanation = document.createElement('div');
            explanation.style.cssText = 'position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #FFD700; font-weight: bold; text-align: center; font-size: 0.9rem;';
            explanation.innerHTML = `${chargeType === 'positive' ? 'Positive' : 'Negative'} charges REPEL each other!<br><span style="color: #FF6B6B;">Force pushes them apart ‚Üê‚Üí</span>`;
            demoArea.appendChild(explanation);
            
            // Add real-world examples
            setTimeout(() => {
                addRealWorldRepulsionExamples(demoArea, chargeType);
            }, 2000);
        }

        function demonstrateAttraction(demoType) {
            const demoArea = document.getElementById('attractionDemo');
            
            // Clear previous demonstration
            demoArea.innerHTML = '';
            
            if (demoType === 'subatomic') {
                // Proton and electron attraction
                const proton = document.createElement('div');
                const electron = document.createElement('div');
                
                proton.className = 'charge-particle positive';
                electron.className = 'charge-particle negative';
                
                proton.innerHTML = '+';
                electron.innerHTML = '-';
                
                proton.style.left = '60px';
                proton.style.top = '80px';
                electron.style.left = '140px';
                electron.style.top = '80px';
                
                // Add attraction animation
                proton.style.setProperty('--attract-distance', '20px');
                electron.style.setProperty('--attract-distance', '-20px');
                
                setTimeout(() => {
                    proton.classList.add('attracting');
                    electron.classList.add('attracting');
                }, 500);
                
                // Create force lines showing attraction
                const forceLine = document.createElement('div');
                forceLine.className = 'force-line attraction';
                forceLine.style.left = '80px';
                forceLine.style.top = '98px';
                forceLine.style.width = '80px';
                
                demoArea.appendChild(proton);
                demoArea.appendChild(electron);
                demoArea.appendChild(forceLine);
                
                // Add explanation
                const explanation = document.createElement('div');
                explanation.style.cssText = 'position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #FFD700; font-weight: bold; text-align: center; font-size: 0.9rem;';
                explanation.innerHTML = 'Proton (+) and Electron (-) ATTRACT!<br><span style="color: #32CD32;">Force pulls them together ‚Üí‚Üê</span>';
                demoArea.appendChild(explanation);
                
                // Add orbital motion simulation
                setTimeout(() => {
                    simulateElectronOrbit(demoArea, proton, electron);
                }, 3000);
                
            } else if (demoType === 'realworld') {
                // Real world charged objects
                const balloon = document.createElement('div');
                const hair = document.createElement('div');
                
                balloon.className = 'real-world-object charged-negative';
                hair.className = 'real-world-object charged-positive';
                
                balloon.innerHTML = 'üéà Balloon (-)';
                hair.innerHTML = 'üíá‚Äç‚ôÄÔ∏è Hair (+)';
                
                balloon.style.left = '20px';
                balloon.style.top = '60px';
                hair.style.left = '120px';
                hair.style.top = '60px';
                
                // Add attraction animation
                balloon.style.setProperty('--attract-distance', '15px');
                hair.style.setProperty('--attract-distance', '-15px');
                
                setTimeout(() => {
                    balloon.classList.add('attracting');
                    hair.classList.add('attracting');
                }, 500);
                
                // Create force lines
                const forceLine = document.createElement('div');
                forceLine.className = 'force-line attraction';
                forceLine.style.left = '70px';
                forceLine.style.top = '78px';
                forceLine.style.width = '80px';
                
                demoArea.appendChild(balloon);
                demoArea.appendChild(hair);
                demoArea.appendChild(forceLine);
                
                // Add explanation
                const explanation = document.createElement('div');
                explanation.style.cssText = 'position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #FFD700; font-weight: bold; text-align: center; font-size: 0.9rem;';
                explanation.innerHTML = 'Charged balloon attracts hair!<br><span style="color: #32CD32;">Static electricity in action!</span>';
                demoArea.appendChild(explanation);
                
                // Add more real-world examples
                setTimeout(() => {
                    addMoreRealWorldExamples(demoArea);
                }, 3000);
            }
        }

        function addRealWorldRepulsionExamples(container, chargeType) {
            // Clear existing content and add new examples
            const examples = document.createElement('div');
            examples.style.cssText = 'position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 1rem; border-radius: 8px; border: 1px solid #FFD700; max-width: 200px;';
            
            if (chargeType === 'positive') {
                examples.innerHTML = `
                    <h5 style="color: #FFD700; margin: 0 0 0.5rem 0;">Real Examples:</h5>
                    <div style="color: white; font-size: 0.8rem; line-height: 1.4;">
                        ‚Ä¢ Two balloons rubbed on hair<br>
                        ‚Ä¢ Charged plastic combs<br>
                        ‚Ä¢ Van de Graaff generator spheres<br>
                        ‚Ä¢ Positive ions in plasma
                    </div>
                `;
            } else {
                examples.innerHTML = `
                    <h5 style="color: #FFD700; margin: 0 0 0.5rem 0;">Real Examples:</h5>
                    <div style="color: white; font-size: 0.8rem; line-height: 1.4;">
                        ‚Ä¢ Two electrons in an atom<br>
                        ‚Ä¢ Negatively charged dust particles<br>
                        ‚Ä¢ Charged droplets in clouds<br>
                        ‚Ä¢ Negative ions in solution
                    </div>
                `;
            }
            
            container.appendChild(examples);
        }

        function simulateElectronOrbit(container, proton, electron) {
            // Create orbital path
            const orbitPath = document.createElement('div');
            orbitPath.style.cssText = `
                position: absolute;
                width: 120px;
                height: 120px;
                border: 2px dashed #87CEEB;
                border-radius: 50%;
                left: 40px;
                top: 40px;
                opacity: 0.5;
            `;
            container.appendChild(orbitPath);
            
            // Animate electron in orbit around proton
            let angle = 0;
            const centerX = 100;
            const centerY = 100;
            const radius = 50;
            
            const orbitAnimation = setInterval(() => {
                angle += 0.1;
                const x = centerX + radius * Math.cos(angle) - 20;
                const y = centerY + radius * Math.sin(angle) - 20;
                
                electron.style.left = x + 'px';
                electron.style.top = y + 'px';
                
                // Stop after a few orbits
                if (angle > 4 * Math.PI) {
                    clearInterval(orbitAnimation);
                }
            }, 50);
            
            // Update explanation
            setTimeout(() => {
                const explanation = container.querySelector('div[style*="bottom: 10px"]');
                if (explanation) {
                    explanation.innerHTML = 'Electron orbits the proton!<br><span style="color: #87CEEB;">This forms a hydrogen atom ‚öõÔ∏è</span>';
                }
            }, 1000);
        }

        function addMoreRealWorldExamples(container) {
            const moreExamples = document.createElement('div');
            moreExamples.style.cssText = 'position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 1rem; border-radius: 8px; border: 1px solid #32CD32; max-width: 220px;';
            moreExamples.innerHTML = `
                <h5 style="color: #32CD32; margin: 0 0 0.5rem 0;">More Attraction Examples:</h5>
                <div style="color: white; font-size: 0.8rem; line-height: 1.4;">
                    üéà Balloon sticks to wall<br>
                    üìÑ Paper attracted to charged comb<br>
                    ‚ö° Lightning between clouds<br>
                    üñ®Ô∏è Toner particles in printers<br>
                    üì± Capacitive touchscreens<br>
                    üß≤ Electrostatic air filters
                </div>
            `;
            container.appendChild(moreExamples);
        }

        // Drag and drop functionality
        let draggedElement = null;
        let playgroundParticles = [];
        let subatomicSimulationParticles = [];
        let realWorldSimulationParticles = [];

        /* Sound manager: small, synthesized UI sounds using WebAudio (preloaded on first user gesture) */
        const soundManager = (function(){
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            let ctx = null;
            let master = null;
            let muted = localStorage.getItem('ec_sound_muted') === '1';

            function ensure() {
                if (!ctx) {
                    try {
                        ctx = new AudioCtx();
                        master = ctx.createGain();
                        master.gain.value = muted ? 0 : 0.06; // low default volume
                        master.connect(ctx.destination);
                    } catch (e) {
                        ctx = null;
                    }
                } else if (ctx.state === 'suspended') {
                    ctx.resume();
                }
            }

            function playTone(frequency, duration = 0.08, type = 'sine', volume = 0.06) {
                ensure(); if (!ctx) return;
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.type = type; o.frequency.value = frequency;
                g.gain.value = volume;
                o.connect(g); g.connect(master);
                const now = ctx.currentTime;
                g.gain.setValueAtTime(volume, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + duration);
                o.start(now); o.stop(now + duration + 0.02);
            }

            function playNoise(duration = 0.12, volume = 0.03) {
                ensure(); if (!ctx) return;
                const bufferSize = ctx.sampleRate * duration;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * (1 - i/bufferSize);
                const src = ctx.createBufferSource(); src.buffer = buffer;
                const g = ctx.createGain(); g.gain.value = volume;
                src.connect(g); g.connect(master);
                src.start(); src.stop(ctx.currentTime + duration + 0.02);
            }

            return {
                playWhoosh: function(){ playNoise(0.12, 0.02); },
                playClick: function(){ playTone(1000, 0.06, 'square', 0.05); },
                playRub: function(){ playNoise(0.18, 0.035); },
                playZap: function(){ playTone(1500, 0.04, 'sawtooth', 0.06); playNoise(0.06,0.02); },
                playSpark: function(){ playTone(1800,0.03,'triangle',0.05); },
                playReset: function(){ playTone(600,0.08,'sine',0.04); },
                toggleMute: function(){ muted = !muted; localStorage.setItem('ec_sound_muted', muted ? '1' : '0'); if (master) master.gain.value = muted ? 0 : 0.06; return !muted; },
                isMuted: function(){ return muted; },
                ensureUserGesture: function(){ ensure(); }
            };
        })();

        document.addEventListener('DOMContentLoaded', function() {
            createElectricityEffects();
            setupDragAndDrop();
            setupMainSimulationDragAndDrop();
            // initialize a small sound toggle UI and ensure audio context created on first interaction
            setupSoundToggleUI();
        });

        function setupSoundToggleUI() {
            // create a small floating toggle button
            const btn = document.createElement('button');
            btn.id = 'soundToggleBtn';
            btn.title = 'Toggle simulation sounds';
            btn.style.cssText = 'position:fixed;right:12px;top:12px;z-index:99999;padding:6px 8px;border-radius:8px;background:rgba(0,0,0,0.5);color:#7df9ff;border:1px solid rgba(125,249,255,0.14);backdrop-filter:blur(4px);cursor:pointer;font-weight:700;';
            btn.innerText = soundManager.isMuted() ? 'üîà' : 'üîä';
            btn.addEventListener('click', (e) => {
                soundManager.ensureUserGesture();
                const nowUnmuted = soundManager.toggleMute();
                btn.innerText = nowUnmuted ? 'üîä' : 'üîà';
            });
            document.body.appendChild(btn);
            // ensure AudioContext is resumed on first user gesture anywhere
            ['pointerdown','click','keydown'].forEach(evt => document.addEventListener(evt, () => soundManager.ensureUserGesture(), {once:true}));
        }

        function setupDragAndDrop() {
            const draggableItems = document.querySelectorAll('.draggable-item');
            const dropZones = document.querySelectorAll('.drop-zone');
            const playgroundArea = document.getElementById('playgroundArea');

            draggableItems.forEach(item => {
                setupSingleItemDragAndDrop(item);
            });

            dropZones.forEach(zone => {
                zone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('drag-over');
                });

                zone.addEventListener('dragleave', function() {
                    this.classList.remove('drag-over');
                });

                zone.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');
                    
                    if (draggedElement) {
                        handleDrop(this, draggedElement);
                        draggedElement = null;
                    }
                });
            });

            // Setup conduction simulation area drag and drop
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            if (conductionSimulationArea) {
                conductionSimulationArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('drag-over');
                });

                conductionSimulationArea.addEventListener('dragleave', function() {
                    this.classList.remove('drag-over');
                });

                conductionSimulationArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');
                    
                    if (draggedElement) {
                        handleConductionSimulationDrop(e, draggedElement);
                        draggedElement = null;
                    }
                });
            }

            // Setup playground drag and drop
            if (playgroundArea) {
                playgroundArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#FFD700';
                });

                playgroundArea.addEventListener('dragleave', function() {
                    this.style.borderColor = '#DC143C';
                });

                playgroundArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#DC143C';
                    
                    if (draggedElement && draggedElement.classList.contains('particle-item')) {
                        handlePlaygroundDrop(e, draggedElement);
                        draggedElement = null;
                    }
                });
            }

            // Setup main simulation drag and drop
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            if (mainPlaygroundArea) {
                mainPlaygroundArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#FFD700';
                });

                mainPlaygroundArea.addEventListener('dragleave', function() {
                    this.style.borderColor = '#DC143C';
                });

                mainPlaygroundArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#DC143C';
                    
                    if (draggedElement && draggedElement.classList.contains('particle-item')) {
                        handleMainSimulationDrop(e, draggedElement);
                        draggedElement = null;
                    }
                });
            }
        }

        function setupSingleItemDragAndDrop(item) {
            item.addEventListener('dragstart', function(e) {
                draggedElement = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                try { soundManager.playWhoosh(); } catch(e){}
            });

            item.addEventListener('dragend', function() {
                this.classList.remove('dragging');
            });
        }

        function handleDrop(dropZone, draggedItem) {
            const itemType = draggedItem.getAttribute('data-type');
            const zoneId = dropZone.id;
            
            // Handle different drop zones
            switch(zoneId) {
                case 'rubbingZone':
                case 'conductionZone':
                case 'inductionZone':
                    handleChargingDrop(itemType, draggedItem);
                    break;
                case 'chargingZone':
                    handleChargingDrop(itemType, draggedItem);
                    break;
            }
            
            // Create a copy instead of removing for these interactive zones
            if (zoneId === 'chargingZone' || zoneId === 'inductionZone' || zoneId === 'rubbingZone' || zoneId === 'conductionZone') {
                const newItem = draggedItem.cloneNode(true);
                draggedItem.parentNode.appendChild(newItem);
                // Re-setup drag and drop for the new item
                setupSingleItemDragAndDrop(newItem);
                try { soundManager.playClick(); } catch(e){}
            } else {
                draggedItem.remove();
                try { soundManager.playClick(); } catch(e){}
            }
        }

        function handlePlaygroundDrop(event, draggedItem) {
            const playgroundArea = document.getElementById('playgroundArea');
            const particleType = draggedItem.getAttribute('data-particle');
            
            // Clear placeholder text if this is the first particle
            if (playgroundParticles.length === 0) {
                playgroundArea.innerHTML = '';
            }
            
            // Get drop position relative to playground area
            const rect = playgroundArea.getBoundingClientRect();
            const x = event.clientX - rect.left - 25; // Center the particle
            const y = event.clientY - rect.top - 25;
            
            // Create particle in playground
            const particle = createPlaygroundParticle(particleType, x, y);
            playgroundArea.appendChild(particle);
            try { soundManager.playClick(); } catch(e){}
            
            // Add to tracking array
            playgroundParticles.push(particle);
            
            // Setup dragging within playground
            setupPlaygroundParticleDrag(particle);
            
            // Check for interactions with existing particles
            setTimeout(() => {
                checkPlaygroundInteractions(particle);
            }, 100);
        }

        function createPlaygroundParticle(type, x, y) {
            const particle = document.createElement('div');
            particle.className = `subatomic-particle ${type}`;
            particle.dataset.type = type;
            particle.style.left = Math.max(0, Math.min(x, 400)) + 'px';
            particle.style.top = Math.max(0, Math.min(y, 250)) + 'px';
            
            // Set particle properties based on type
            switch(type) {
                case 'proton':
                    particle.innerHTML = '+';
                    particle.dataset.charge = 'positive';
                    break;
                case 'electron':
                    particle.innerHTML = '-';
                    particle.dataset.charge = 'negative';
                    break;
            }
            
            // Add remove button
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '√ó';
            removeBtn.style.cssText = `
                position: absolute;
                top: -8px;
                right: -8px;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #FF4444;
                color: white;
                border: none;
                cursor: pointer;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removePlaygroundParticle(particle);
            };
            particle.appendChild(removeBtn);
            
            return particle;
        }

        // Helper: extract icon and name from a sidebar/draggable element when available
        function extractIconNameFromElement(elem) {
            if (!elem) return {icon: null, name: null};
            // Look for explicit structured icon/name
            const iconEl = elem.querySelector && elem.querySelector('.object-icon');
            const nameEl = elem.querySelector && elem.querySelector('.object-name');
            if (iconEl || nameEl) {
                return { icon: iconEl ? iconEl.innerHTML : null, name: nameEl ? nameEl.textContent.trim() : null };
            }

            // Fallback: try to parse a leading emoji or glyph from innerText
            const txt = (elem.textContent || '').trim();
            if (!txt) return {icon: null, name: null};

            // Common pattern: emoji followed by space then label
            const match = txt.match(/^([\u{1F300}-\u{1FAFF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\w\u00A9\u00AE\u203C\u2049\u2122]+)\s+(.*)$/u);
            if (match) {
                return { icon: match[1], name: match[2].trim() };
            }

            return { icon: null, name: txt };
        }

        // Helper: determine if two simulation objects are the same material/type
        function objectsSameMaterial(obj1, obj2) {
            if (!obj1 || !obj2) return false;
            const t1 = obj1.dataset.type;
            const t2 = obj2.dataset.type;
            if (t1 && t2 && t1 === t2) return true;

            // Try to resolve material from known data maps
            let d1 = null, d2 = null;
            try { d1 = (typeof getObjectData === 'function') ? getObjectData(t1) : null; } catch(e) {}
            try { if (!d1 && typeof getConductionObjectData === 'function') d1 = getConductionObjectData(t1); } catch(e) {}
            try { if (!d1 && typeof getRealWorldParticleData === 'function') d1 = getRealWorldParticleData(t1); } catch(e) {}
            try { d2 = (typeof getObjectData === 'function') ? getObjectData(t2) : null; } catch(e) {}
            try { if (!d2 && typeof getConductionObjectData === 'function') d2 = getConductionObjectData(t2); } catch(e) {}
            try { if (!d2 && typeof getRealWorldParticleData === 'function') d2 = getRealWorldParticleData(t2); } catch(e) {}

            if (d1 && d2 && d1.material && d2.material && d1.material === d2.material) return true;
            return false;
        }

        function showPhysicsInfoMessage(container, text) {
            if (!container) return;
            const msg = document.createElement('div');
            msg.style.cssText = 'position:absolute;left:50%;top:10px;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:#E6FFFF;padding:0.6rem 1rem;border-radius:8px;border:1px solid rgba(125,249,255,0.14);z-index:1200;font-weight:700;';
            msg.textContent = text;
            container.appendChild(msg);
            setTimeout(() => { if (msg.parentNode) msg.remove(); }, 3000);
        }

        function setupPlaygroundParticleDrag(particle) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            particle.addEventListener('mousedown', function(e) {
                if (e.target.tagName === 'BUTTON') return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = particle.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                particle.style.cursor = 'grabbing';
                particle.style.zIndex = '1000';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const playgroundArea = document.getElementById('playgroundArea');
                const playgroundRect = playgroundArea.getBoundingClientRect();
                
                const newX = initialX + deltaX - playgroundRect.left;
                const newY = initialY + deltaY - playgroundRect.top;
                
                // Keep particle within playground bounds
                const boundedX = Math.max(0, Math.min(newX, playgroundRect.width - 50));
                const boundedY = Math.max(0, Math.min(newY, playgroundRect.height - 50));
                
                particle.style.left = boundedX + 'px';
                particle.style.top = boundedY + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (!isDragging) return;
                
                isDragging = false;
                particle.style.cursor = 'grab';
                particle.style.zIndex = 'auto';
                
                // Check for interactions after moving
                setTimeout(() => {
                    checkPlaygroundInteractions(particle);
                }, 100);
            });
        }

        function checkPlaygroundInteractions(movedParticle) {
            const playgroundArea = document.getElementById('playgroundArea');
            
            playgroundParticles.forEach(otherParticle => {
                if (otherParticle === movedParticle) return;
                
                const distance = getParticleDistance(movedParticle, otherParticle);
                
                if (distance < 100) { // Particles are close enough to interact
                    const charge1 = movedParticle.dataset.charge;
                    const charge2 = otherParticle.dataset.charge;
                    
                    if (charge1 !== 'neutral' && charge2 !== 'neutral') {
                        if (charge1 === charge2) {
                            // Like charges repel
                            showPlaygroundRepulsion(movedParticle, otherParticle);
                        } else {
                            // Unlike charges attract
                            showPlaygroundAttraction(movedParticle, otherParticle);
                        }
                    }
                }
            });
        }

        function getParticleDistance(particle1, particle2) {
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerY1 = rect1.top + rect1.height / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            const centerY2 = rect2.top + rect2.height / 2;
            
            return Math.sqrt(Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2));
        }

        function showPlaygroundRepulsion(particle1, particle2) {
            // Clear any existing animations
            particle1.classList.remove('attracting-particle', 'repelling-particle');
            particle2.classList.remove('attracting-particle', 'repelling-particle');
            
            // Calculate repulsion direction
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                particle1.style.setProperty('--repel-distance', '-30px');
                particle2.style.setProperty('--repel-distance', '30px');
            } else {
                particle1.style.setProperty('--repel-distance', '30px');
                particle2.style.setProperty('--repel-distance', '-30px');
            }
            
            // Add repulsion animation
            particle1.classList.add('repelling-particle');
            particle2.classList.add('repelling-particle');
            
            // Show force field
            createPlaygroundForceField(particle1, particle2, 'repulsion');
        }

        function showPlaygroundAttraction(particle1, particle2) {
            // Clear any existing animations
            particle1.classList.remove('attracting-particle', 'repelling-particle');
            particle2.classList.remove('attracting-particle', 'repelling-particle');
            
            // Calculate attraction direction
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                particle1.style.setProperty('--attract-distance', '15px');
                particle2.style.setProperty('--attract-distance', '-15px');
            } else {
                particle1.style.setProperty('--attract-distance', '-15px');
                particle2.style.setProperty('--attract-distance', '15px');
            }
            
            // Add attraction animation
            particle1.classList.add('attracting-particle');
            particle2.classList.add('attracting-particle');
            
            // Show force field
            createPlaygroundForceField(particle1, particle2, 'attraction');
        }

        function createPlaygroundForceField(particle1, particle2, type) {
            const playgroundArea = document.getElementById('playgroundArea');
            
            // Remove existing force fields
            const existingFields = playgroundArea.querySelectorAll('.force-field');
            existingFields.forEach(field => field.remove());
            
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const playgroundRect = playgroundArea.getBoundingClientRect();
            
            const centerX = ((rect1.left + rect1.width/2) + (rect2.left + rect2.width/2)) / 2 - playgroundRect.left;
            const centerY = ((rect1.top + rect1.height/2) + (rect2.top + rect2.height/2)) / 2 - playgroundRect.top;
            
            const field = document.createElement('div');
            field.className = `force-field ${type}`;
            field.style.left = (centerX - 40) + 'px';
            field.style.top = (centerY - 40) + 'px';
            field.style.width = '80px';
            field.style.height = '80px';
            
            playgroundArea.appendChild(field);
            
            // Remove force field after animation
            setTimeout(() => {
                if (field.parentNode) {
                    field.remove();
                }
            }, 4000);
        }

        function removePlaygroundParticle(particle) {
            // Remove from tracking array
            const index = playgroundParticles.indexOf(particle);
            if (index > -1) {
                playgroundParticles.splice(index, 1);
            }
            
            // Remove particle with animation
            particle.style.animation = 'dropAnimation 0.3s ease-out reverse';
            setTimeout(() => {
                particle.remove();
                
                // Reset playground if empty
                if (playgroundParticles.length === 0) {
                    const playgroundArea = document.getElementById('playgroundArea');
                    playgroundArea.innerHTML = `
                        <div style="color: #FFD700; font-style: italic; text-align: center; padding: 3rem;">
                            Drag particles here to see how they interact!<br>
                            <span style="color: #87CEEB; font-size: 0.9rem;">Watch for attraction and repulsion forces</span>
                        </div>
                    `;
                }
            }, 300);
        }

        function clearPlayground() {
            const playgroundArea = document.getElementById('playgroundArea');
            
            // Clear all particles
            playgroundParticles.forEach(particle => {
                particle.style.animation = 'dropAnimation 0.3s ease-out reverse';
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.remove();
                    }
                }, 300);
            });
            
            // Reset tracking array
            playgroundParticles = [];
            
            // Reset playground content
            setTimeout(() => {
                playgroundArea.innerHTML = `
                    <div style="color: #FFD700; font-style: italic; text-align: center; padding: 3rem;">
                        Drag particles here to see how they interact!<br>
                        <span style="color: #87CEEB; font-size: 0.9rem;">Watch for attraction and repulsion forces</span>
                    </div>
                `;
            }, 400);
        }

        // Main Simulation Drag and Drop Setup
        function setupMainSimulationDragAndDrop() {
            // Setup Subatomic Simulation Area
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            if (subatomicPlaygroundArea) {
                subatomicPlaygroundArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('drag-over');
                });

                subatomicPlaygroundArea.addEventListener('dragleave', function() {
                    this.classList.remove('drag-over');
                });

                subatomicPlaygroundArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');
                    
                    if (draggedElement && draggedElement.classList.contains('particle-item')) {
                        handleSubatomicSimulationDrop(e, draggedElement);
                        draggedElement = null;
                    }
                });
            }

            // Setup Real World Simulation Area
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            if (realWorldPlaygroundArea) {
                realWorldPlaygroundArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('drag-over');
                });

                realWorldPlaygroundArea.addEventListener('dragleave', function() {
                    this.classList.remove('drag-over');
                });

                realWorldPlaygroundArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');
                    
                    if (draggedElement && draggedElement.classList.contains('particle-item')) {
                        handleRealWorldSimulationDrop(e, draggedElement);
                        draggedElement = null;
                    }
                });
            }
        }

        function handleSubatomicSimulationDrop(event, draggedItem) {
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            const particleType = draggedItem.getAttribute('data-particle');
            const chargeType = draggedItem.getAttribute('data-charge');
            
            // Only allow subatomic particles in subatomic area
            if (particleType !== 'proton' && particleType !== 'electron') {
                return;
            }
            
            // Clear placeholder text if this is the first particle
            if (subatomicSimulationParticles.length === 0) {
                subatomicPlaygroundArea.innerHTML = '';
            }
            
            // Get drop position relative to subatomic playground area
            const rect = subatomicPlaygroundArea.getBoundingClientRect();
            const x = event.clientX - rect.left - 30; // Center the particle
            const y = event.clientY - rect.top - 30;
            
            // Create particle in subatomic simulation
            const particle = createSubatomicSimulationParticle(particleType, chargeType, x, y);
            subatomicPlaygroundArea.appendChild(particle);
            
            // Add to tracking array
            subatomicSimulationParticles.push(particle);
            
            // Setup dragging within subatomic simulation
            setupSubatomicSimulationParticleDrag(particle);
            
            // Start continuous simulation if we have multiple particles
            if (subatomicSimulationParticles.length >= 2 && !subatomicSimulationRunning) {
                startSubatomicSimulation();
                updateSubatomicToggleButton();
            }
            
            // Check for interactions with existing particles
            setTimeout(() => {
                checkSubatomicSimulationInteractions(particle);
            }, 100);
        }

        function handleRealWorldSimulationDrop(event, draggedItem) {
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            const particleType = draggedItem.getAttribute('data-particle');
            const chargeType = draggedItem.getAttribute('data-charge');
            
            // Only allow real world objects in real world area
            if (particleType === 'proton' || particleType === 'electron') {
                return;
            }
            
            // Clear placeholder text if this is the first particle
            if (realWorldSimulationParticles.length === 0) {
                realWorldPlaygroundArea.innerHTML = '';
            }
            
            // Get drop position relative to real world playground area
            const rect = realWorldPlaygroundArea.getBoundingClientRect();
            const x = event.clientX - rect.left - 30; // Center the particle
            const y = event.clientY - rect.top - 30;
            
            // Create particle in real world simulation
            const particle = createRealWorldSimulationParticle(particleType, chargeType, x, y);
            realWorldPlaygroundArea.appendChild(particle);
            
            // Add to tracking array
            realWorldSimulationParticles.push(particle);
            
            // Setup dragging within real world simulation
            setupRealWorldSimulationParticleDrag(particle);
            
            // Start continuous simulation if we have multiple particles
            if (realWorldSimulationParticles.length >= 2 && !realWorldSimulationRunning) {
                startRealWorldSimulation();
                updateRealWorldToggleButton();
            }
            
            // Check for interactions with existing particles
            setTimeout(() => {
                checkRealWorldSimulationInteractions(particle);
            }, 100);
        }
        
        function toggleSubatomicSimulation() {
            if (subatomicSimulationParticles.length < 2) {
                showSimulationMessage('Need at least 2 particles to start physics simulation!', '#FF6B6B');
                return;
            }
            
            if (subatomicSimulationRunning) {
                stopSubatomicSimulation();
            } else {
                startSubatomicSimulation();
            }
            
            updateSubatomicToggleButton();
        }

        function toggleRealWorldSimulation() {
            if (realWorldSimulationParticles.length < 2) {
                showSimulationMessage('Need at least 2 objects to start physics simulation!', '#FF6B6B');
                return;
            }
            
            if (realWorldSimulationRunning) {
                stopRealWorldSimulation();
            } else {
                startRealWorldSimulation();
            }
            
            updateRealWorldToggleButton();
        }
        
        function updateSubatomicToggleButton() {
            const toggleButton = document.getElementById('subatomicToggle');
            if (!toggleButton) return;
            
            if (subatomicSimulationRunning) {
                toggleButton.innerHTML = '‚è∏Ô∏è Pause Physics';
                toggleButton.style.background = 'linear-gradient(145deg, #FF6B6B, #DC143C)';
            } else {
                toggleButton.innerHTML = '‚ñ∂Ô∏è Start Physics';
                toggleButton.style.background = 'linear-gradient(145deg, #32CD32, #228B22)';
            }
        }

        function updateRealWorldToggleButton() {
            const toggleButton = document.getElementById('realWorldToggle');
            if (!toggleButton) return;
            
            if (realWorldSimulationRunning) {
                toggleButton.innerHTML = '‚è∏Ô∏è Pause Physics';
                toggleButton.style.background = 'linear-gradient(145deg, #FF6B6B, #DC143C)';
            } else {
                toggleButton.innerHTML = '‚ñ∂Ô∏è Start Physics';
                toggleButton.style.background = 'linear-gradient(145deg, #32CD32, #228B22)';
            }
        }
        
        function showSimulationMessage(message, color) {
            // No popup messages - status shown in top display only
        }

        // Subatomic Simulation Functions
        function startSubatomicSimulation() {
            if (subatomicSimulationRunning) return;
            
            subatomicSimulationRunning = true;
            
            // Initialize random velocities for all particles and add physics glow
            subatomicSimulationParticles.forEach(particle => {
                if (!particle.velocity) {
                    particle.velocity = {
                        x: (Math.random() - 0.5) * 2,
                        y: (Math.random() - 0.5) * 2
                    };
                }
                particle.classList.add('physics-active', 'continuous-movement');
            });
            
            function subatomicSimulationLoop() {
                if (!subatomicSimulationRunning) return;
                
                updateSubatomicParticlePositions();
                applySubatomicInteractionForces();
                
                subatomicAnimationFrameId = requestAnimationFrame(subatomicSimulationLoop);
            }
            
            subatomicSimulationLoop();
        }

        function stopSubatomicSimulation() {
            subatomicSimulationRunning = false;
            if (subatomicAnimationFrameId) {
                cancelAnimationFrame(subatomicAnimationFrameId);
                subatomicAnimationFrameId = null;
            }
            
            // Remove physics glow from all particles
            subatomicSimulationParticles.forEach(particle => {
                particle.classList.remove('physics-active', 'continuous-movement');
            });
            
            // Clear interaction lines and explanations
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            if (subatomicPlaygroundArea) {
                const interactionElements = subatomicPlaygroundArea.querySelectorAll('.interaction-line, .interaction-explanation');
                interactionElements.forEach(element => element.remove());
            }
        }

        function updateSubatomicParticlePositions() {
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            const playgroundRect = subatomicPlaygroundArea.getBoundingClientRect();
            
            subatomicSimulationParticles.forEach(particle => {
                // Skip particles that are bonded (they move as a unit)
                if (particle.dataset.bondedTo && !particle.dataset.bondLeader) {
                    return;
                }
                
                if (!particle.velocity) {
                    particle.velocity = {
                        x: (Math.random() - 0.5) * 2,
                        y: (Math.random() - 0.5) * 2
                    };
                }
                
                // Get current position
                let currentX = parseFloat(particle.style.left) || 0;
                let currentY = parseFloat(particle.style.top) || 0;
                
                // Update position based on velocity
                currentX += particle.velocity.x;
                currentY += particle.velocity.y;
                
                // Bounce off walls
                if (currentX <= 0 || currentX >= playgroundRect.width - 60) {
                    particle.velocity.x *= -0.8;
                    currentX = Math.max(0, Math.min(currentX, playgroundRect.width - 60));
                }
                
                if (currentY <= 0 || currentY >= playgroundRect.height - 60) {
                    particle.velocity.y *= -0.8;
                    currentY = Math.max(0, Math.min(currentY, playgroundRect.height - 60));
                }
                
                // Apply some random motion for natural movement
                const randomFactor = particle.dataset.bondedTo ? 0.05 : 0.1;
                particle.velocity.x += (Math.random() - 0.5) * randomFactor;
                particle.velocity.y += (Math.random() - 0.5) * randomFactor;
                
                // Limit maximum velocity
                const maxVelocity = particle.dataset.bondedTo ? 1.5 : 3;
                const speed = Math.sqrt(particle.velocity.x * particle.velocity.x + particle.velocity.y * particle.velocity.y);
                if (speed > maxVelocity) {
                    particle.velocity.x = (particle.velocity.x / speed) * maxVelocity;
                    particle.velocity.y = (particle.velocity.y / speed) * maxVelocity;
                }
                
                // Apply friction to gradually slow down
                particle.velocity.x *= 0.99;
                particle.velocity.y *= 0.99;
                
                // Update particle position
                particle.style.left = currentX + 'px';
                particle.style.top = currentY + 'px';
                
                // If this particle is bonded, move its partner too
                if (particle.dataset.bondedTo && particle.dataset.bondLeader) {
                    const partner = subatomicSimulationParticles.find(p => 
                        p.dataset.type === particle.dataset.bondedTo && 
                        p.dataset.bondedTo === particle.dataset.type
                    );
                    
                    if (partner) {
                        partner.velocity = {...particle.velocity};
                        
                        const partnerX = parseFloat(partner.style.left) || 0;
                        const partnerY = parseFloat(partner.style.top) || 0;
                        
                        partner.style.left = (partnerX + particle.velocity.x) + 'px';
                        partner.style.top = (partnerY + particle.velocity.y) + 'px';
                        
                        if (particle.bondLine) {
                            updateBondLinePosition(particle.bondLine, particle, partner);
                        }
                    }
                }
            });
        }

        function applySubatomicInteractionForces() {
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            
            // Clear existing interaction lines
            const existingLines = subatomicPlaygroundArea.querySelectorAll('.interaction-line');
            existingLines.forEach(line => line.remove());
            
            // Check all particle pairs for interactions
            for (let i = 0; i < subatomicSimulationParticles.length; i++) {
                for (let j = i + 1; j < subatomicSimulationParticles.length; j++) {
                    const particle1 = subatomicSimulationParticles[i];
                    const particle2 = subatomicSimulationParticles[j];
                    
                    // Skip interactions if either particle is bonded
                    if (particle1.dataset.bondedTo || particle2.dataset.bondedTo) {
                        continue;
                    }
                    
                    const distance = getSubatomicSimulationDistance(particle1, particle2);
                    
                    if (distance < 200) {
                        const charge1 = particle1.dataset.charge;
                        const charge2 = particle2.dataset.charge;
                        
                        if (charge1 === charge2) {
                            // Like charges repel
                            applySubatomicRepulsion(particle1, particle2, distance);
                            createSubatomicInteractionLine(particle1, particle2, 'repulsion');
                        } else {
                            // Unlike charges attract
                            applySubatomicAttraction(particle1, particle2, distance);
                            createSubatomicInteractionLine(particle1, particle2, 'attraction');
                        }
                    }
                }
            }
        }

        // Real World Simulation Functions
        function startRealWorldSimulation() {
            if (realWorldSimulationRunning) return;
            
            realWorldSimulationRunning = true;
            
            // Initialize random velocities for all particles and add physics glow
            realWorldSimulationParticles.forEach(particle => {
                if (!particle.velocity) {
                    particle.velocity = {
                        x: (Math.random() - 0.5) * 1.5,
                        y: (Math.random() - 0.5) * 1.5
                    };
                }
                particle.classList.add('physics-active', 'continuous-movement');
            });
            
            function realWorldSimulationLoop() {
                if (!realWorldSimulationRunning) return;
                
                updateRealWorldParticlePositions();
                applyRealWorldInteractionForces();
                
                realWorldAnimationFrameId = requestAnimationFrame(realWorldSimulationLoop);
            }
            
            realWorldSimulationLoop();
        }

        function stopRealWorldSimulation() {
            realWorldSimulationRunning = false;
            if (realWorldAnimationFrameId) {
                cancelAnimationFrame(realWorldAnimationFrameId);
                realWorldAnimationFrameId = null;
            }
            
            // Remove physics glow from all particles
            realWorldSimulationParticles.forEach(particle => {
                particle.classList.remove('physics-active', 'continuous-movement', 'polarized-particle');
            });
            
            // Clear interaction lines and explanations
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            if (realWorldPlaygroundArea) {
                const interactionElements = realWorldPlaygroundArea.querySelectorAll('.interaction-line, .interaction-explanation');
                interactionElements.forEach(element => element.remove());
            }
        }

        function updateRealWorldParticlePositions() {
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            const playgroundRect = realWorldPlaygroundArea.getBoundingClientRect();
            
            realWorldSimulationParticles.forEach(particle => {
                if (!particle.velocity) {
                    particle.velocity = {
                        x: (Math.random() - 0.5) * 1.5,
                        y: (Math.random() - 0.5) * 1.5
                    };
                }
                
                // Get current position
                let currentX = parseFloat(particle.style.left) || 0;
                let currentY = parseFloat(particle.style.top) || 0;
                
                // Update position based on velocity
                currentX += particle.velocity.x;
                currentY += particle.velocity.y;
                
                // Bounce off walls
                if (currentX <= 0 || currentX >= playgroundRect.width - 60) {
                    particle.velocity.x *= -0.7;
                    currentX = Math.max(0, Math.min(currentX, playgroundRect.width - 60));
                }
                
                if (currentY <= 0 || currentY >= playgroundRect.height - 60) {
                    particle.velocity.y *= -0.7;
                    currentY = Math.max(0, Math.min(currentY, playgroundRect.height - 60));
                }
                
                // Apply some random motion for natural movement
                particle.velocity.x += (Math.random() - 0.5) * 0.08;
                particle.velocity.y += (Math.random() - 0.5) * 0.08;
                
                // Limit maximum velocity (slower for real world objects)
                const maxVelocity = 2;
                const speed = Math.sqrt(particle.velocity.x * particle.velocity.x + particle.velocity.y * particle.velocity.y);
                if (speed > maxVelocity) {
                    particle.velocity.x = (particle.velocity.x / speed) * maxVelocity;
                    particle.velocity.y = (particle.velocity.y / speed) * maxVelocity;
                }
                
                // Apply friction to gradually slow down
                particle.velocity.x *= 0.98;
                particle.velocity.y *= 0.98;
                
                // Update particle position
                particle.style.left = currentX + 'px';
                particle.style.top = currentY + 'px';
            });
        }

        function applyRealWorldInteractionForces() {
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            
            // Clear existing interaction lines
            const existingLines = realWorldPlaygroundArea.querySelectorAll('.interaction-line');
            existingLines.forEach(line => line.remove());
            
            // Check all particle pairs for interactions
            for (let i = 0; i < realWorldSimulationParticles.length; i++) {
                for (let j = i + 1; j < realWorldSimulationParticles.length; j++) {
                    const particle1 = realWorldSimulationParticles[i];
                    const particle2 = realWorldSimulationParticles[j];
                    
                    const distance = getRealWorldSimulationDistance(particle1, particle2);
                    
                    if (distance < 180) {
                        const charge1 = particle1.dataset.charge;
                        const charge2 = particle2.dataset.charge;
                        
                        if (charge1 === 'neutral' || charge2 === 'neutral') {
                            // Polarization effect
                            applyPolarizationEffect(particle1, particle2, distance);
                            createRealWorldInteractionLine(particle1, particle2, 'polarization');
                        } else if (charge1 === charge2) {
                            // Like charges repel
                            applyRealWorldRepulsion(particle1, particle2, distance);
                            createRealWorldInteractionLine(particle1, particle2, 'repulsion');
                        } else {
                            // Unlike charges attract
                            applyRealWorldAttraction(particle1, particle2, distance);
                            createRealWorldInteractionLine(particle1, particle2, 'attraction');
                        }
                    }
                }
            }
        }

        function createSubatomicSimulationParticle(type, charge, x, y) {
            const particle = document.createElement('div');
            particle.className = `subatomic-particle ${type}`;
            particle.dataset.type = type;
            particle.dataset.charge = charge;
            particle.style.left = Math.max(0, Math.min(x, 500)) + 'px';
            particle.style.top = Math.max(0, Math.min(y, 320)) + 'px';
            
            // Set particle content and properties based on type
            const particleData = getParticleDisplayData(type, charge);
            particle.innerHTML = particleData.symbol;
            particle.title = particleData.name;
            
            // Add remove button
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '√ó';
            removeBtn.className = 'remove-btn';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removeSubatomicSimulationParticle(particle);
            };
            particle.appendChild(removeBtn);
            
            return particle;
        }

        function createRealWorldSimulationParticle(type, charge, x, y) {
            const particle = document.createElement('div');
            particle.className = `real-world-particle ${type}`;
            particle.dataset.type = type;
            particle.dataset.charge = charge;
            particle.style.left = Math.max(0, Math.min(x, 500)) + 'px';
            particle.style.top = Math.max(0, Math.min(y, 320)) + 'px';

            // Set particle content and properties based on type (use canonical mapping)
            const particleData = getRealWorldParticleData(type, charge);
            particle.innerHTML = `
                <div class="object-icon">${particleData.icon}</div>
                <div class="object-name">${particleData.name}</div>
            `;
            particle.title = particleData.description;
            
            // Add remove button
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '√ó';
            removeBtn.className = 'remove-btn';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removeRealWorldSimulationParticle(particle);
            };
            particle.appendChild(removeBtn);
            
            return particle;
        }

        function getRealWorldParticleData(type, charge) {
            const particleMap = {
                'balloon': { icon: 'üéà', name: 'Balloon', description: 'Rubber balloon (negative charge after rubbing)' },
                'comb': { icon: 'üíá', name: 'Comb', description: 'Plastic comb (negative charge after use)' },
                'rod-positive': { icon: 'üî¨', name: 'Glass Rod', description: 'Glass rod (positive charge after rubbing with silk)' },
                'rod-negative': { icon: 'üñäÔ∏è', name: 'Plastic Rod', description: 'Plastic rod (negative charge after rubbing)' },
                'hair': { icon: 'üíá‚Äç‚ôÄÔ∏è', name: 'Hair', description: 'Human hair (positive charge after combing)' },
                'paper': { icon: 'üìÑ', name: 'Paper', description: 'Small paper pieces (neutral, can be polarized)' },
                'dust': { icon: 'üí®', name: 'Dust', description: 'Dust particles (neutral, can be polarized)' },
                'water-drop': { icon: 'üíß', name: 'Water', description: 'Water droplet (neutral, polar molecule)' }
            };
            
            return particleMap[type] || { icon: '‚ùì', name: 'Unknown', description: 'Unknown object' };
        }

        function getParticleDisplayData(type, charge) {
            const particleMap = {
                'proton': { symbol: '+', name: 'Proton (Positive Charge)' },
                'electron': { symbol: '-', name: 'Electron (Negative Charge)' }
            };
            
            return particleMap[type] || { symbol: '?', name: 'Unknown Particle' };
        }

        function setupMainSimulationParticleDrag(particle) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            particle.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('remove-btn')) return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = particle.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                particle.style.cursor = 'grabbing';
                particle.style.zIndex = '1000';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
                const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
                
                const newX = initialX + deltaX - playgroundRect.left;
                const newY = initialY + deltaY - playgroundRect.top;
                
                // Keep particle within playground bounds
                const boundedX = Math.max(0, Math.min(newX, playgroundRect.width - 60));
                const boundedY = Math.max(0, Math.min(newY, playgroundRect.height - 60));
                
                particle.style.left = boundedX + 'px';
                particle.style.top = boundedY + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (!isDragging) return;
                
                isDragging = false;
                particle.style.cursor = 'grab';
                particle.style.zIndex = 'auto';
                
                // Check for interactions after moving
                setTimeout(() => {
                    checkMainSimulationInteractions(particle);
                }, 100);
            });
        }

        // Continuous movement and interaction system
        let subatomicSimulationRunning = false;
        let realWorldSimulationRunning = false;
        let subatomicAnimationFrameId = null;
        let realWorldAnimationFrameId = null;
        
        function checkSubatomicSimulationInteractions(movedParticle) {
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            
            // Clear existing interaction lines
            const existingLines = subatomicPlaygroundArea.querySelectorAll('.interaction-line');
            existingLines.forEach(line => line.remove());
            
            // Clear existing animations
            subatomicSimulationParticles.forEach(p => {
                p.classList.remove('repelling-particle', 'attracting-particle');
            });
            
            subatomicSimulationParticles.forEach(otherParticle => {
                if (otherParticle === movedParticle) return;
                
                const distance = getSubatomicSimulationDistance(movedParticle, otherParticle);
                
                if (distance < 150) { // Particles are close enough to interact
                    const charge1 = movedParticle.dataset.charge;
                    const charge2 = otherParticle.dataset.charge;
                    
                    if (charge1 === charge2) {
                        // Like charges repel
                        showSubatomicSimulationRepulsion(movedParticle, otherParticle);
                        createSubatomicInteractionLine(movedParticle, otherParticle, 'repulsion');
                    } else {
                        // Unlike charges attract
                        showSubatomicSimulationAttraction(movedParticle, otherParticle);
                        createSubatomicInteractionLine(movedParticle, otherParticle, 'attraction');
                    }
                }
            });
        }

        function checkRealWorldSimulationInteractions(movedParticle) {
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            
            // Clear existing interaction lines
            const existingLines = realWorldPlaygroundArea.querySelectorAll('.interaction-line');
            existingLines.forEach(line => line.remove());
            
            // Clear existing animations
            realWorldSimulationParticles.forEach(p => {
                p.classList.remove('repelling-particle', 'attracting-particle', 'polarized-particle');
            });
            
            realWorldSimulationParticles.forEach(otherParticle => {
                if (otherParticle === movedParticle) return;
                
                const distance = getRealWorldSimulationDistance(movedParticle, otherParticle);
                
                if (distance < 150) { // Particles are close enough to interact
                    const charge1 = movedParticle.dataset.charge;
                    const charge2 = otherParticle.dataset.charge;
                    
                    if (charge1 === 'neutral' || charge2 === 'neutral') {
                        // Polarization effect
                        showRealWorldSimulationPolarization(movedParticle, otherParticle);
                        createRealWorldInteractionLine(movedParticle, otherParticle, 'polarization');
                    } else if (charge1 === charge2) {
                        // Like charges repel
                        showRealWorldSimulationRepulsion(movedParticle, otherParticle);
                        createRealWorldInteractionLine(movedParticle, otherParticle, 'repulsion');
                    } else {
                        // Unlike charges attract
                        showRealWorldSimulationAttraction(movedParticle, otherParticle);
                        createRealWorldInteractionLine(movedParticle, otherParticle, 'attraction');
                    }
                }
            });
        }

        function checkMainSimulationInteractions(movedParticle) {
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            
            // Clear existing interaction lines
            const existingLines = mainPlaygroundArea.querySelectorAll('.interaction-line');
            existingLines.forEach(line => line.remove());
            
            // Clear existing animations
            mainSimulationParticles.forEach(p => {
                p.classList.remove('repelling-particle', 'attracting-particle', 'polarization-effect');
            });
            
            mainSimulationParticles.forEach(otherParticle => {
                if (otherParticle === movedParticle) return;
                
                const distance = getMainSimulationDistance(movedParticle, otherParticle);
                
                if (distance < 150) { // Particles are close enough to interact
                    const charge1 = movedParticle.dataset.charge;
                    const charge2 = otherParticle.dataset.charge;
                    
                    if (charge1 === charge2) {
                        // Like charges repel (proton-proton or electron-electron)
                        showMainSimulationRepulsion(movedParticle, otherParticle);
                        // Apply automatic repulsion force
                        applyRepulsionForce(movedParticle, otherParticle);
                    } else {
                        // Unlike charges attract (proton-electron)
                        showMainSimulationAttraction(movedParticle, otherParticle);
                        // Apply automatic attraction force
                        applyAttractionForce(movedParticle, otherParticle);
                    }
                }
            });
        }
        
        function startContinuousSimulation() {
            if (simulationRunning) return;
            
            simulationRunning = true;
            
            // Initialize random velocities for all particles and add physics glow
            mainSimulationParticles.forEach(particle => {
                if (!particle.velocity) {
                    particle.velocity = {
                        x: (Math.random() - 0.5) * 2, // Random velocity between -1 and 1
                        y: (Math.random() - 0.5) * 2
                    };
                }
                particle.classList.add('physics-active', 'continuous-movement');
            });
            
            function simulationLoop() {
                if (!simulationRunning) return;
                
                updateParticlePositions();
                applyInteractionForces();
                
                animationFrameId = requestAnimationFrame(simulationLoop);
            }
            
            simulationLoop();
        }
        
        function stopContinuousSimulation() {
            simulationRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Remove physics glow from all particles
            mainSimulationParticles.forEach(particle => {
                particle.classList.remove('physics-active', 'continuous-movement');
            });
            
            // Clear interaction lines and explanations
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            if (mainPlaygroundArea) {
                const interactionElements = mainPlaygroundArea.querySelectorAll('.interaction-line, .interaction-explanation');
                interactionElements.forEach(element => element.remove());
            }
        }
        
        function updateParticlePositions() {
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            mainSimulationParticles.forEach(particle => {
                // Skip particles that are bonded (they move as a unit)
                if (particle.dataset.bondedTo && !particle.dataset.bondLeader) {
                    return;
                }
                
                if (!particle.velocity) {
                    particle.velocity = {
                        x: (Math.random() - 0.5) * 2,
                        y: (Math.random() - 0.5) * 2
                    };
                }
                
                // Get current position
                let currentX = parseFloat(particle.style.left) || 0;
                let currentY = parseFloat(particle.style.top) || 0;
                
                // Update position based on velocity
                currentX += particle.velocity.x;
                currentY += particle.velocity.y;
                
                // Bounce off walls
                if (currentX <= 0 || currentX >= playgroundRect.width - 60) {
                    particle.velocity.x *= -0.8; // Damping on bounce
                    currentX = Math.max(0, Math.min(currentX, playgroundRect.width - 60));
                }
                
                if (currentY <= 0 || currentY >= playgroundRect.height - 60) {
                    particle.velocity.y *= -0.8; // Damping on bounce
                    currentY = Math.max(0, Math.min(currentY, playgroundRect.height - 60));
                }
                
                // Apply some random motion for natural movement (less for bonded particles)
                const randomFactor = particle.dataset.bondedTo ? 0.05 : 0.1;
                particle.velocity.x += (Math.random() - 0.5) * randomFactor;
                particle.velocity.y += (Math.random() - 0.5) * randomFactor;
                
                // Limit maximum velocity (slower for bonded particles)
                const maxVelocity = particle.dataset.bondedTo ? 1.5 : 3;
                const speed = Math.sqrt(particle.velocity.x * particle.velocity.x + particle.velocity.y * particle.velocity.y);
                if (speed > maxVelocity) {
                    particle.velocity.x = (particle.velocity.x / speed) * maxVelocity;
                    particle.velocity.y = (particle.velocity.y / speed) * maxVelocity;
                }
                
                // Apply friction to gradually slow down
                particle.velocity.x *= 0.99;
                particle.velocity.y *= 0.99;
                
                // Update particle position
                particle.style.left = currentX + 'px';
                particle.style.top = currentY + 'px';
                
                // If this particle is bonded, move its partner too
                if (particle.dataset.bondedTo && particle.dataset.bondLeader) {
                    const partner = mainSimulationParticles.find(p => 
                        p.dataset.type === particle.dataset.bondedTo && 
                        p.dataset.bondedTo === particle.dataset.type
                    );
                    
                    if (partner) {
                        // Move partner with same velocity
                        partner.velocity = {...particle.velocity};
                        
                        const partnerX = parseFloat(partner.style.left) || 0;
                        const partnerY = parseFloat(partner.style.top) || 0;
                        
                        partner.style.left = (partnerX + particle.velocity.x) + 'px';
                        partner.style.top = (partnerY + particle.velocity.y) + 'px';
                        
                        // Update bond line position
                        if (particle.bondLine) {
                            updateBondLinePosition(particle.bondLine, particle, partner);
                        }
                    }
                }
            });
        }
        
        function applyInteractionForces() {
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            
            // Clear existing interaction lines
            const existingLines = mainPlaygroundArea.querySelectorAll('.interaction-line');
            existingLines.forEach(line => line.remove());
            
            // Check all particle pairs for interactions
            for (let i = 0; i < mainSimulationParticles.length; i++) {
                for (let j = i + 1; j < mainSimulationParticles.length; j++) {
                    const particle1 = mainSimulationParticles[i];
                    const particle2 = mainSimulationParticles[j];
                    
                    // CRITICAL: Skip interactions if either particle is bonded to something
                    // Bonded particles are electrically neutral as a unit and don't interact with other charges
                    if (particle1.dataset.bondedTo || particle2.dataset.bondedTo) {
                        continue; // Skip this pair completely
                    }
                    
                    const distance = getMainSimulationDistance(particle1, particle2);
                    
                    if (distance < 200) { // Interaction range
                        const charge1 = particle1.dataset.charge;
                        const charge2 = particle2.dataset.charge;
                        
                        if (charge1 === charge2) {
                            // Like charges repel
                            applyContinuousRepulsion(particle1, particle2, distance);
                            createMainSimulationInteractionLine(particle1, particle2, 'repulsion');
                        } else {
                            // Unlike charges attract
                            applyContinuousAttraction(particle1, particle2, distance);
                            createMainSimulationInteractionLine(particle1, particle2, 'attraction');
                        }
                    }
                }
            }
            
            // Update interaction explanation based on current forces
            updateInteractionExplanation();
        }
        
        function applyContinuousRepulsion(particle1, particle2, distance) {
            if (distance < 10) return; // Avoid division by zero
            
            // Calculate direction vector from particle2 to particle1
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const dx = centerX1 - centerX2;
            const dy = centerY1 - centerY2;
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Calculate repulsion force (stronger when closer, following inverse square law)
            const forceStrength = Math.min(2, 500 / (distance * distance));
            
            // Apply force to velocities
            if (!particle1.velocity) particle1.velocity = {x: 0, y: 0};
            if (!particle2.velocity) particle2.velocity = {x: 0, y: 0};
            
            particle1.velocity.x += normalizedDx * forceStrength;
            particle1.velocity.y += normalizedDy * forceStrength;
            
            particle2.velocity.x -= normalizedDx * forceStrength;
            particle2.velocity.y -= normalizedDy * forceStrength;
        }
        
        function applyContinuousAttraction(particle1, particle2, distance) {
            // Check if particles are already bonded
            if (particle1.dataset.bondedTo === particle2.dataset.type || particle2.dataset.bondedTo === particle1.dataset.type) {
                // Keep particles close together when bonded
                maintainBond(particle1, particle2);
                return;
            }
            
            if (distance < 50) {
                // Particles are close enough to form a permanent bond
                formPermanentBond(particle1, particle2);
                return;
            }
            
            // Calculate direction vector from particle1 to particle2
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const dx = centerX2 - centerX1;
            const dy = centerY2 - centerY1;
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Calculate attraction force (stronger when closer, but not too strong)
            const forceStrength = Math.min(1.5, 300 / (distance * distance));
            
            // Apply force to velocities
            if (!particle1.velocity) particle1.velocity = {x: 0, y: 0};
            if (!particle2.velocity) particle2.velocity = {x: 0, y: 0};
            
            particle1.velocity.x += normalizedDx * forceStrength;
            particle1.velocity.y += normalizedDy * forceStrength;
            
            particle2.velocity.x -= normalizedDx * forceStrength;
            particle2.velocity.y -= normalizedDy * forceStrength;
        }
        
        function formPermanentBond(particle1, particle2) {
            // Mark particles as bonded to each other
            particle1.dataset.bondedTo = particle2.dataset.type;
            particle2.dataset.bondedTo = particle1.dataset.type;
            
            // Stop their individual velocities
            particle1.velocity = {x: 0, y: 0};
            particle2.velocity = {x: 0, y: 0};
            
            // Position them close together
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            const centerX = ((rect1.left + rect1.width/2) + (rect2.left + rect2.width/2)) / 2 - playgroundRect.left;
            const centerY = ((rect1.top + rect1.height/2) + (rect2.top + rect2.height/2)) / 2 - playgroundRect.top;
            
            // Position particles 45px apart (touching distance)
            particle1.style.left = (centerX - 22.5) + 'px';
            particle1.style.top = centerY + 'px';
            particle2.style.left = (centerX + 22.5) + 'px';
            particle2.style.top = centerY + 'px';
            
            // Add visual bond indicator
            particle1.classList.add('bonded-particle');
            particle2.classList.add('bonded-particle');
            
            // Create bond line between particles
            createBondLine(particle1, particle2);
            
            // Show bond formation message
            showBondFormationMessage(particle1, particle2);
        }
        
        function maintainBond(particle1, particle2) {
            // Keep bonded particles at a fixed distance from each other
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const currentDistance = Math.sqrt((centerX2 - centerX1) ** 2 + (centerY2 - centerY1) ** 2);
            const targetDistance = 45; // Fixed bond distance
            
            if (Math.abs(currentDistance - targetDistance) > 5) {
                // Adjust positions to maintain bond distance
                const midX = (centerX1 + centerX2) / 2;
                const midY = (centerY1 + centerY2) / 2;
                
                const angle = Math.atan2(centerY2 - centerY1, centerX2 - centerX1);
                
                particle1.style.left = (midX - (targetDistance / 2) * Math.cos(angle) - 25) + 'px';
                particle1.style.top = (midY - (targetDistance / 2) * Math.sin(angle) - 25) + 'px';
                particle2.style.left = (midX + (targetDistance / 2) * Math.cos(angle) - 25) + 'px';
                particle2.style.top = (midY + (targetDistance / 2) * Math.sin(angle) - 25) + 'px';
            }
            
            // Move bonded pair together with slight random motion
            if (!particle1.dataset.bondLeader) {
                particle1.dataset.bondLeader = 'true';
                
                const sharedVelocity = {
                    x: (Math.random() - 0.5) * 0.5,
                    y: (Math.random() - 0.5) * 0.5
                };
                
                particle1.velocity = sharedVelocity;
                particle2.velocity = sharedVelocity;
            }
        }
        
        function createBondLine(particle1, particle2) {
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            
            // Remove any existing bond line for these particles
            const existingBonds = mainPlaygroundArea.querySelectorAll('.bond-line');
            existingBonds.forEach(bond => {
                if (bond.dataset.particle1 === particle1.dataset.type || bond.dataset.particle2 === particle2.dataset.type) {
                    bond.remove();
                }
            });
            
            const bondLine = document.createElement('div');
            bondLine.className = 'bond-line';
            bondLine.dataset.particle1 = particle1.dataset.type;
            bondLine.dataset.particle2 = particle2.dataset.type;
            
            bondLine.style.cssText = `
                position: absolute;
                height: 4px;
                background: linear-gradient(to right, #32CD32, #FFD700, #32CD32);
                border-radius: 2px;
                z-index: 5;
                animation: bondGlow 2s ease-in-out infinite;
                box-shadow: 0 0 10px #32CD32;
            `;
            
            // Position the bond line between particles
            updateBondLinePosition(bondLine, particle1, particle2);
            
            mainPlaygroundArea.appendChild(bondLine);
            
            // Store reference to bond line in particles
            particle1.bondLine = bondLine;
            particle2.bondLine = bondLine;
        }
        
        function updateBondLinePosition(bondLine, particle1, particle2) {
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const length = Math.sqrt((centerX2 - centerX1) ** 2 + (centerY2 - centerY1) ** 2);
            const angle = Math.atan2(centerY2 - centerY1, centerX2 - centerX1) * 180 / Math.PI;
            
            bondLine.style.width = length + 'px';
            bondLine.style.left = centerX1 + 'px';
            bondLine.style.top = (centerY1 - 2) + 'px';
            bondLine.style.transform = `rotate(${angle}deg)`;
            bondLine.style.transformOrigin = '0 50%';
        }
        
        function showBondFormationMessage(particle1, particle2) {
            // No popup message - bond formation shown through visual effects only
        }

        function updateInteractionExplanation() {
            // No popup messages - interactions shown only through visual effects
        }

        function getMainSimulationDistance(particle1, particle2) {
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerY1 = rect1.top + rect1.height / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            const centerY2 = rect2.top + rect2.height / 2;
            
            return Math.sqrt(Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2));
        }

        function showMainSimulationRepulsion(particle1, particle2) {
            // Clear any existing animations
            particle1.classList.remove('attracting-particle', 'polarization-effect');
            particle2.classList.remove('attracting-particle', 'polarization-effect');
            
            // Calculate repulsion direction
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                particle1.style.setProperty('--repel-distance', '-40px');
                particle2.style.setProperty('--repel-distance', '40px');
            } else {
                particle1.style.setProperty('--repel-distance', '40px');
                particle2.style.setProperty('--repel-distance', '-40px');
            }
            
            // Add repulsion animation
            particle1.classList.add('repelling-particle');
            particle2.classList.add('repelling-particle');
            
            // Create interaction line
            createMainSimulationInteractionLine(particle1, particle2, 'repulsion');
        }

        function showMainSimulationAttraction(particle1, particle2) {
            // Clear any existing animations
            particle1.classList.remove('repelling-particle', 'polarization-effect');
            particle2.classList.remove('repelling-particle', 'polarization-effect');
            
            // Calculate attraction direction
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                particle1.style.setProperty('--attract-distance', '20px');
                particle2.style.setProperty('--attract-distance', '-20px');
            } else {
                particle1.style.setProperty('--attract-distance', '-20px');
                particle2.style.setProperty('--attract-distance', '20px');
            }
            
            // Add attraction animation
            particle1.classList.add('attracting-particle');
            particle2.classList.add('attracting-particle');
            
            // Create interaction line
            createMainSimulationInteractionLine(particle1, particle2, 'attraction');
        }

        function showMainSimulationPolarization(neutralParticle, chargedParticle) {
            // Clear any existing animations
            neutralParticle.classList.remove('repelling-particle', 'attracting-particle');
            
            // Add polarization effect to neutral particle
            neutralParticle.classList.add('polarization-effect');
            
            // Create interaction line
            createMainSimulationInteractionLine(neutralParticle, chargedParticle, 'polarization');
        }

        function createMainSimulationInteractionLine(particle1, particle2, type) {
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = (rect1.left + rect1.width/2) - playgroundRect.left;
            const centerY1 = (rect1.top + rect1.height/2) - playgroundRect.top;
            const centerX2 = (rect2.left + rect2.width/2) - playgroundRect.left;
            const centerY2 = (rect2.top + rect2.height/2) - playgroundRect.top;
            
            const line = document.createElement('div');
            line.className = `interaction-line ${type}`;
            
            const length = Math.sqrt(Math.pow(centerX2 - centerX1, 2) + Math.pow(centerY2 - centerY1, 2));
            const angle = Math.atan2(centerY2 - centerY1, centerX2 - centerX1) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.left = centerX1 + 'px';
            line.style.top = (centerY1 - 1.5) + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 50%';
            
            mainPlaygroundArea.appendChild(line);
            
            // Remove line after animation
            setTimeout(() => {
                if (line.parentNode) {
                    line.remove();
                }
            }, 4000);
        }

        function showInteractionExplanation(type, message, color) {
            // No popup messages - interactions shown only through visual effects
        }

        function removeMainSimulationParticle(particle) {
            // Remove from tracking array
            const index = mainSimulationParticles.indexOf(particle);
            if (index > -1) {
                mainSimulationParticles.splice(index, 1);
            }
            
            // Clear any interaction lines
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const interactionLines = mainPlaygroundArea.querySelectorAll('.interaction-line');
            interactionLines.forEach(line => line.remove());
            
            // Remove particle with animation
            particle.style.animation = 'dropAnimation 0.3s ease-out reverse';
            setTimeout(() => {
                particle.remove();
                
                // Reset playground if empty
                if (mainSimulationParticles.length === 0) {
                    clearMainSimulation();
                }
            }, 300);
        }

        function applyRepulsionForce(particle1, particle2) {
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            // Calculate direction vector from particle2 to particle1
            const centerX1 = rect1.left + rect1.width / 2;
            const centerY1 = rect1.top + rect1.height / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            const centerY2 = rect2.top + rect2.height / 2;
            
            const dx = centerX1 - centerX2;
            const dy = centerY1 - centerY2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 10) return; // Avoid division by zero
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Calculate repulsion force (stronger when closer)
            const forceStrength = Math.max(5, 100 / distance);
            
            // Apply force to particle1 (push away from particle2)
            const currentX1 = parseFloat(particle1.style.left) || 0;
            const currentY1 = parseFloat(particle1.style.top) || 0;
            
            const newX1 = currentX1 + normalizedDx * forceStrength;
            const newY1 = currentY1 + normalizedDy * forceStrength;
            
            // Keep within bounds
            const boundedX1 = Math.max(0, Math.min(newX1, playgroundRect.width - 60));
            const boundedY1 = Math.max(0, Math.min(newY1, playgroundRect.height - 60));
            
            particle1.style.left = boundedX1 + 'px';
            particle1.style.top = boundedY1 + 'px';
            
            // Apply opposite force to particle2 (push away from particle1)
            const currentX2 = parseFloat(particle2.style.left) || 0;
            const currentY2 = parseFloat(particle2.style.top) || 0;
            
            const newX2 = currentX2 - normalizedDx * forceStrength;
            const newY2 = currentY2 - normalizedDy * forceStrength;
            
            // Keep within bounds
            const boundedX2 = Math.max(0, Math.min(newX2, playgroundRect.width - 60));
            const boundedY2 = Math.max(0, Math.min(newY2, playgroundRect.height - 60));
            
            particle2.style.left = boundedX2 + 'px';
            particle2.style.top = boundedY2 + 'px';
        }
        
        function applyAttractionForce(particle1, particle2) {
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const mainPlaygroundArea = document.getElementById('mainPlaygroundArea');
            const playgroundRect = mainPlaygroundArea.getBoundingClientRect();
            
            // Calculate direction vector from particle1 to particle2
            const centerX1 = rect1.left + rect1.width / 2;
            const centerY1 = rect1.top + rect1.height / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            const centerY2 = rect2.top + rect2.height / 2;
            
            const dx = centerX2 - centerX1;
            const dy = centerY2 - centerY1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 70) return; // Stop attracting when very close to avoid overlap
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Calculate attraction force (stronger when closer, but not too strong)
            const forceStrength = Math.min(8, 80 / distance);
            
            // Apply force to particle1 (pull toward particle2)
            const currentX1 = parseFloat(particle1.style.left) || 0;
            const currentY1 = parseFloat(particle1.style.top) || 0;
            
            const newX1 = currentX1 + normalizedDx * forceStrength;
            const newY1 = currentY1 + normalizedDy * forceStrength;
            
            // Keep within bounds
            const boundedX1 = Math.max(0, Math.min(newX1, playgroundRect.width - 60));
            const boundedY1 = Math.max(0, Math.min(newY1, playgroundRect.height - 60));
            
            particle1.style.left = boundedX1 + 'px';
            particle1.style.top = boundedY1 + 'px';
            
            // Apply opposite force to particle2 (pull toward particle1)
            const currentX2 = parseFloat(particle2.style.left) || 0;
            const currentY2 = parseFloat(particle2.style.top) || 0;
            
            const newX2 = currentX2 - normalizedDx * forceStrength;
            const newY2 = currentY2 - normalizedDy * forceStrength;
            
            // Keep within bounds
            const boundedX2 = Math.max(0, Math.min(newX2, playgroundRect.width - 60));
            const boundedY2 = Math.max(0, Math.min(newY2, playgroundRect.height - 60));
            
            particle2.style.left = boundedX2 + 'px';
            particle2.style.top = boundedY2 + 'px';
        }

        // Van de Graaff Generator Modal Functions
        function openVanDeGraaffModal() {
            const modal = document.getElementById('vanDeGraaffModal');
            modal.style.display = 'flex';
            
            // Reset the simulation when opening
            resetVanDeGraaffDemo();
        }

        function closeVanDeGraaffModal() {
            const modal = document.getElementById('vanDeGraaffModal');
            modal.style.display = 'none';
            
            // Reset the simulation when closing
            resetVanDeGraaffDemo();
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('vanDeGraaffModal');
            if (event.target === modal) {
                closeVanDeGraaffModal();
            }
        });

        // Van de Graaff Generator Simulation Functions
        let vanDeGraaffState = {
            isRunning: false,
            isCharged: false,
            personTouching: false,
            chargeLevel: 0
        };

        function startVanDeGraaffDemo() {
            const dome = document.getElementById('vanDeGraaffDome');
            const domeChargeIndicator = document.getElementById('domeChargeIndicator');
            const statusText = document.getElementById('statusText');
            
            if (vanDeGraaffState.isRunning) {
                statusText.textContent = 'Generator already running!';
                return;
            }
            
            vanDeGraaffState.isRunning = true;
            statusText.textContent = 'Building up charge...';
            
            // Add spinning effect to dome
            dome.style.animation = 'chargeBuildup 3s ease-in-out';
            
            // Gradually build up charge
            let chargeProgress = 0;
            const chargeInterval = setInterval(() => {
                chargeProgress += 10;
                vanDeGraaffState.chargeLevel = chargeProgress;
                
                if (chargeProgress >= 100) {
                    clearInterval(chargeInterval);
                    vanDeGraaffState.isCharged = true;
                    
                    // Show charge indicator
                    domeChargeIndicator.style.display = 'flex';
                    
                    // Add electric field effect
                    dome.style.boxShadow = '0 0 30px #FFD700, 0 0 50px #FF6B6B';
                    
                    statusText.innerHTML = 'Dome fully charged!<br><span style="color: #32CD32;">Ready to touch</span>';
                    
                    // Create electric field visualization
                    createElectricFieldLines();
                }
            }, 100);
        }

        function touchVanDeGraaffDome() {
            const personFigure = document.getElementById('personFigure');
            const personChargeIndicator = document.getElementById('personChargeIndicator');
            const statusText = document.getElementById('statusText');
            const rightArm = document.getElementById('rightArm');
            
            if (!vanDeGraaffState.isCharged) {
                statusText.innerHTML = 'Start generator first!<br><span style="color: #FF6B6B;">Dome needs charge</span>';
                return;
            }
            
            if (vanDeGraaffState.personTouching) {
                statusText.textContent = 'Person already touching dome!';
                return;
            }
            
            vanDeGraaffState.personTouching = true;
            
            // Show person
            personFigure.style.display = 'block';
            personFigure.style.animation = 'fadeIn 0.5s ease-in-out';
            
            // Move arm to touch dome
            rightArm.style.transform = 'rotate(-45deg)';
            
            statusText.textContent = 'Person approaching dome...';
            
            setTimeout(() => {
                // Show electron transfer
                showVanDeGraaffElectronTransfer();
                
                setTimeout(() => {
                    // Person becomes charged
                    personChargeIndicator.style.display = 'flex';
                    
                    // Hair stands up!
                    makeHairStandUp();
                    
                    statusText.innerHTML = 'Charge transferred!<br><span style="color: #FFD700;">Hair standing up!</span>';
                    
                    // Show explanation
                    setTimeout(() => {
                        showVanDeGraaffExplanation();
                    }, 2000);
                }, 1500);
            }, 1000);
        }

        function resetVanDeGraaffDemo() {
            const dome = document.getElementById('vanDeGraaffDome');
            const domeChargeIndicator = document.getElementById('domeChargeIndicator');
            const personFigure = document.getElementById('personFigure');
            const personChargeIndicator = document.getElementById('personChargeIndicator');
            const statusText = document.getElementById('statusText');
            const rightArm = document.getElementById('rightArm');
            const chargeFlowContainer = document.getElementById('chargeFlowContainer');
            
            // Reset state
            vanDeGraaffState = {
                isRunning: false,
                isCharged: false,
                personTouching: false,
                chargeLevel: 0
            };
            
            // Reset visual elements
            dome.style.animation = '';
            dome.style.boxShadow = '';
            domeChargeIndicator.style.display = 'none';
            personFigure.style.display = 'none';
            personChargeIndicator.style.display = 'none';
            rightArm.style.transform = '';
            chargeFlowContainer.innerHTML = '';
            
            // Reset hair
            const hairStrands = document.querySelectorAll('.hair-strand');
            hairStrands.forEach(strand => {
                strand.style.transform = '';
            });
            
            // Clear field lines
            const fieldLines = document.querySelectorAll('.electric-field-line');
            fieldLines.forEach(line => line.remove());
            
            statusText.textContent = 'Ready to start';
        }

        function createElectricFieldLines() {
            const simulation = document.getElementById('vanDeGraaffSimulation');
            const dome = document.getElementById('vanDeGraaffDome');
            const domeRect = dome.getBoundingClientRect();
            const simRect = simulation.getBoundingClientRect();
            
            // Create field lines radiating from dome
            for (let i = 0; i < 12; i++) {
                const angle = (i * 30) * Math.PI / 180; // Convert to radians
                const line = document.createElement('div');
                line.className = 'electric-field-line';
                
                const startX = (domeRect.left + domeRect.width/2) - simRect.left;
                const startY = (domeRect.top + domeRect.height/2) - simRect.top;
                
                line.style.cssText = `
                    position: absolute;
                    width: 2px;
                    height: 60px;
                    background: linear-gradient(to bottom, #FFD700, transparent);
                    left: ${startX}px;
                    top: ${startY}px;
                    transform-origin: top center;
                    transform: rotate(${i * 30}deg);
                    animation: fieldLinePulse 2s ease-in-out infinite;
                    animation-delay: ${i * 0.1}s;
                `;
                
                simulation.appendChild(line);
            }
        }

        function showVanDeGraaffElectronTransfer() {
            const chargeFlowContainer = document.getElementById('chargeFlowContainer');
            const dome = document.getElementById('vanDeGraaffDome');
            const person = document.getElementById('personFigure');
            
            const domeRect = dome.getBoundingClientRect();
            const personRect = person.getBoundingClientRect();
            const containerRect = chargeFlowContainer.getBoundingClientRect();
            
            // Calculate positions
            const startX = (personRect.left + personRect.width/2) - containerRect.left;
            const startY = (personRect.top + personRect.height/3) - containerRect.top;
            const endX = (domeRect.left + domeRect.width/2) - containerRect.left;
            const endY = (domeRect.top + domeRect.height/2) - containerRect.top;
            
            // Create multiple electrons flowing from person to dome
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const electron = document.createElement('div');
                    electron.style.cssText = `
                        position: absolute;
                        width: 12px;
                        height: 12px;
                        background: radial-gradient(circle, #87CEEB, #4682B4);
                        border-radius: 50%;
                        box-shadow: 0 0 15px #87CEEB;
                        left: ${startX}px;
                        top: ${startY}px;
                        z-index: 1000;
                    `;
                    
                    chargeFlowContainer.appendChild(electron);
                    
                    // Animate electron from person to dome
                    let progress = 0;
                    const animationSpeed = 0.02;
                    
                    const moveElectron = () => {
                        progress += animationSpeed;
                        
                        if (progress >= 1) {
                            electron.remove();
                            return;
                        }
                        
                        const currentX = startX + (endX - startX) * progress;
                        const currentY = startY + (endY - startY) * progress;
                        
                        // Add slight curve to path
                        const curve = Math.sin(progress * Math.PI) * 20;
                        
                        electron.style.left = currentX + 'px';
                        electron.style.top = (currentY - curve) + 'px';
                        
                        // Scale electron as it moves
                        const scale = 1 + Math.sin(progress * Math.PI) * 0.3;
                        electron.style.transform = `scale(${scale})`;
                        
                        requestAnimationFrame(moveElectron);
                    };
                    
                    requestAnimationFrame(moveElectron);
                }, i * 80);
            }
        }

        function makeHairStandUp() {
            const hairStrands = document.querySelectorAll('.hair-strand');
            
            hairStrands.forEach((strand, index) => {
                const strandNumber = parseInt(strand.dataset.strand);
                let rotation = 0;
                
                // Different rotation angles for each strand to create realistic hair standing up
                switch(strandNumber) {
                    case 1: rotation = -45; break;
                    case 2: rotation = -25; break;
                    case 3: rotation = -10; break;
                    case 4: rotation = 10; break;
                    case 5: rotation = 25; break;
                    case 6: rotation = 45; break;
                }
                
                // Add slight random variation
                rotation += (Math.random() - 0.5) * 10;
                
                strand.style.transform = `rotate(${rotation}deg)`;
                strand.style.boxShadow = '0 0 8px #FF6B6B'; // Add charge glow to hair
            });
        }

        function showVanDeGraaffExplanation() {
            const simulation = document.getElementById('vanDeGraaffSimulation');
            
            // Create explanation overlay
            const explanation = document.createElement('div');
            explanation.style.cssText = `
                position: absolute;
                bottom: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.9);
                padding: 1rem;
                border-radius: 10px;
                border: 2px solid #FFD700;
                max-width: 250px;
                z-index: 1001;
                animation: fadeIn 0.5s ease-in-out;
            `;
            
            explanation.innerHTML = `
                <div style="color: #FFD700; font-weight: bold; margin-bottom: 0.5rem; font-size: 0.9rem;">‚ö° What Just Happened?</div>
                <div style="color: #FFFFFF; font-size: 0.8rem; line-height: 1.4;">
                    1. Electrons flowed from person to dome<br>
                    2. Person became positively charged<br>
                    3. Each hair strand repels the others<br>
                    4. Hair stands up to get away from other hairs!<br>
                    <span style="color: #87CEEB;">üí° Like charges always repel!</span>
                </div>
            `;
            
            simulation.appendChild(explanation);
            
            // Remove explanation after 8 seconds
            setTimeout(() => {
                if (explanation.parentNode) {
                    explanation.style.animation = 'fadeOut 0.5s ease-in-out';
                    setTimeout(() => explanation.remove(), 500);
                }
            }, 8000);
        }

        // Missing simulation functions
        function getSubatomicSimulationDistance(particle1, particle2) {
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerY1 = rect1.top + rect1.height / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            const centerY2 = rect2.top + rect2.height / 2;
            
            return Math.sqrt(Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2));
        }

        function getRealWorldSimulationDistance(particle1, particle2) {
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerY1 = rect1.top + rect1.height / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            const centerY2 = rect2.top + rect2.height / 2;
            
            return Math.sqrt(Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2));
        }

        function showSubatomicSimulationRepulsion(particle1, particle2) {
            // Clear any existing animations
            particle1.classList.remove('attracting-particle');
            particle2.classList.remove('attracting-particle');
            
            // Calculate repulsion direction
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                particle1.style.setProperty('--repel-distance', '-40px');
                particle2.style.setProperty('--repel-distance', '40px');
            } else {
                particle1.style.setProperty('--repel-distance', '40px');
                particle2.style.setProperty('--repel-distance', '-40px');
            }
            
            // Add repulsion animation
            particle1.classList.add('repelling-particle');
            particle2.classList.add('repelling-particle');
        }

        function showSubatomicSimulationAttraction(particle1, particle2) {
            // Clear any existing animations
            particle1.classList.remove('repelling-particle');
            particle2.classList.remove('repelling-particle');
            
            // Calculate attraction direction
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                particle1.style.setProperty('--attract-distance', '20px');
                particle2.style.setProperty('--attract-distance', '-20px');
            } else {
                particle1.style.setProperty('--attract-distance', '-20px');
                particle2.style.setProperty('--attract-distance', '20px');
            }
            
            // Add attraction animation
            particle1.classList.add('attracting-particle');
            particle2.classList.add('attracting-particle');
        }

        function showRealWorldSimulationRepulsion(particle1, particle2) {
            // Clear any existing animations
            particle1.classList.remove('attracting-particle', 'polarized-particle');
            particle2.classList.remove('attracting-particle', 'polarized-particle');
            
            // Calculate repulsion direction
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                particle1.style.setProperty('--repel-distance', '-30px');
                particle2.style.setProperty('--repel-distance', '30px');
            } else {
                particle1.style.setProperty('--repel-distance', '30px');
                particle2.style.setProperty('--repel-distance', '-30px');
            }
            
            // Add repulsion animation
            particle1.classList.add('repelling-particle');
            particle2.classList.add('repelling-particle');
        }

        function showRealWorldSimulationAttraction(particle1, particle2) {
            // Clear any existing animations
            particle1.classList.remove('repelling-particle', 'polarized-particle');
            particle2.classList.remove('repelling-particle', 'polarized-particle');
            
            // Calculate attraction direction
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                particle1.style.setProperty('--attract-distance', '15px');
                particle2.style.setProperty('--attract-distance', '-15px');
            } else {
                particle1.style.setProperty('--attract-distance', '-15px');
                particle2.style.setProperty('--attract-distance', '15px');
            }
            
            // Add attraction animation
            particle1.classList.add('attracting-particle');
            particle2.classList.add('attracting-particle');
        }

        function showRealWorldSimulationPolarization(neutralParticle, chargedParticle) {
            // Clear any existing animations
            neutralParticle.classList.remove('repelling-particle', 'attracting-particle');
            
            // Add polarization effect to neutral particle
            neutralParticle.classList.add('polarized-particle');
            
            // Neutral objects are attracted to charged objects
            const rect1 = neutralParticle.getBoundingClientRect();
            const rect2 = chargedParticle.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2;
            const centerX2 = rect2.left + rect2.width / 2;
            
            if (centerX1 < centerX2) {
                neutralParticle.style.setProperty('--attract-distance', '10px');
            } else {
                neutralParticle.style.setProperty('--attract-distance', '-10px');
            }
            
            neutralParticle.classList.add('attracting-particle');
        }

        function createSubatomicInteractionLine(particle1, particle2, type) {
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            const playgroundRect = subatomicPlaygroundArea.getBoundingClientRect();
            
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = (rect1.left + rect1.width/2) - playgroundRect.left;
            const centerY1 = (rect1.top + rect1.height/2) - playgroundRect.top;
            const centerX2 = (rect2.left + rect2.width/2) - playgroundRect.left;
            const centerY2 = (rect2.top + rect2.height/2) - playgroundRect.top;
            
            const line = document.createElement('div');
            line.className = `interaction-line ${type}`;
            
            const length = Math.sqrt(Math.pow(centerX2 - centerX1, 2) + Math.pow(centerY2 - centerY1, 2));
            const angle = Math.atan2(centerY2 - centerY1, centerX2 - centerX1) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.left = centerX1 + 'px';
            line.style.top = (centerY1 - 1.5) + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 50%';
            
            subatomicPlaygroundArea.appendChild(line);
            
            // Remove line after animation
            setTimeout(() => {
                if (line.parentNode) {
                    line.remove();
                }
            }, 4000);
        }

        function createRealWorldInteractionLine(particle1, particle2, type) {
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            const playgroundRect = realWorldPlaygroundArea.getBoundingClientRect();
            
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            
            const centerX1 = (rect1.left + rect1.width/2) - playgroundRect.left;
            const centerY1 = (rect1.top + rect1.height/2) - playgroundRect.top;
            const centerX2 = (rect2.left + rect2.width/2) - playgroundRect.left;
            const centerY2 = (rect2.top + rect2.height/2) - playgroundRect.top;
            
            const line = document.createElement('div');
            line.className = `interaction-line ${type}`;
            
            const length = Math.sqrt(Math.pow(centerX2 - centerX1, 2) + Math.pow(centerY2 - centerY1, 2));
            const angle = Math.atan2(centerY2 - centerY1, centerX2 - centerX1) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.left = centerX1 + 'px';
            line.style.top = (centerY1 - 1.5) + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 50%';
            
            realWorldPlaygroundArea.appendChild(line);
            
            // Remove line after animation
            setTimeout(() => {
                if (line.parentNode) {
                    line.remove();
                }
            }, 4000);
        }

        function applySubatomicRepulsion(particle1, particle2, distance) {
            if (distance < 10) return; // Avoid division by zero
            
            // Calculate direction vector from particle2 to particle1
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            const playgroundRect = subatomicPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const dx = centerX1 - centerX2;
            const dy = centerY1 - centerY2;
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Calculate repulsion force (stronger when closer, following inverse square law)
            const forceStrength = Math.min(2, 500 / (distance * distance));
            
            // Apply force to velocities
            if (!particle1.velocity) particle1.velocity = {x: 0, y: 0};
            if (!particle2.velocity) particle2.velocity = {x: 0, y: 0};
            
            particle1.velocity.x += normalizedDx * forceStrength;
            particle1.velocity.y += normalizedDy * forceStrength;
            
            particle2.velocity.x -= normalizedDx * forceStrength;
            particle2.velocity.y -= normalizedDy * forceStrength;
        }

        function applySubatomicAttraction(particle1, particle2, distance) {
            // Check if particles are already bonded
            if (particle1.dataset.bondedTo === particle2.dataset.type || particle2.dataset.bondedTo === particle1.dataset.type) {
                // Keep particles close together when bonded
                maintainSubatomicBond(particle1, particle2);
                return;
            }
            
            if (distance < 50) {
                // Particles are close enough to form a permanent bond
                formSubatomicPermanentBond(particle1, particle2);
                return;
            }
            
            // Calculate direction vector from particle1 to particle2
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            const playgroundRect = subatomicPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const dx = centerX2 - centerX1;
            const dy = centerY2 - centerY1;
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Calculate attraction force (stronger when closer, but not too strong)
            const forceStrength = Math.min(1.5, 300 / (distance * distance));
            
            // Apply force to velocities
            if (!particle1.velocity) particle1.velocity = {x: 0, y: 0};
            if (!particle2.velocity) particle2.velocity = {x: 0, y: 0};
            
            particle1.velocity.x += normalizedDx * forceStrength;
            particle1.velocity.y += normalizedDy * forceStrength;
            
            particle2.velocity.x -= normalizedDx * forceStrength;
            particle2.velocity.y -= normalizedDy * forceStrength;
        }

        function applyRealWorldRepulsion(particle1, particle2, distance) {
            if (distance < 10) return; // Avoid division by zero
            
            // Calculate direction vector from particle2 to particle1
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            const playgroundRect = realWorldPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const dx = centerX1 - centerX2;
            const dy = centerY1 - centerY2;
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Calculate repulsion force (weaker for real world objects)
            const forceStrength = Math.min(1.5, 300 / (distance * distance));
            
            // Apply force to velocities
            if (!particle1.velocity) particle1.velocity = {x: 0, y: 0};
            if (!particle2.velocity) particle2.velocity = {x: 0, y: 0};
            
            particle1.velocity.x += normalizedDx * forceStrength;
            particle1.velocity.y += normalizedDy * forceStrength;
            
            particle2.velocity.x -= normalizedDx * forceStrength;
            particle2.velocity.y -= normalizedDy * forceStrength;
        }

        function applyRealWorldAttraction(particle1, particle2, distance) {
            if (distance < 30) return; // Stop attracting when very close
            
            // Calculate direction vector from particle1 to particle2
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            const playgroundRect = realWorldPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const dx = centerX2 - centerX1;
            const dy = centerY2 - centerY1;
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Calculate attraction force (weaker for real world objects)
            const forceStrength = Math.min(1, 200 / (distance * distance));
            
            // Apply force to velocities
            if (!particle1.velocity) particle1.velocity = {x: 0, y: 0};
            if (!particle2.velocity) particle2.velocity = {x: 0, y: 0};
            
            particle1.velocity.x += normalizedDx * forceStrength;
            particle1.velocity.y += normalizedDy * forceStrength;
            
            particle2.velocity.x -= normalizedDx * forceStrength;
            particle2.velocity.y -= normalizedDy * forceStrength;
        }

        function applyPolarizationEffect(neutralParticle, chargedParticle, distance) {
            // Neutral objects are weakly attracted to charged objects
            if (distance < 30) return; // Stop when very close
            
            const rect1 = neutralParticle.getBoundingClientRect();
            const rect2 = chargedParticle.getBoundingClientRect();
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            const playgroundRect = realWorldPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const dx = centerX2 - centerX1;
            const dy = centerY2 - centerY1;
            
            // Normalize direction vector
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Weak attraction force for polarization
            const forceStrength = Math.min(0.5, 100 / (distance * distance));
            
            // Apply force only to neutral particle
            if (!neutralParticle.velocity) neutralParticle.velocity = {x: 0, y: 0};
            
            neutralParticle.velocity.x += normalizedDx * forceStrength;
            neutralParticle.velocity.y += normalizedDy * forceStrength;
            
            // Add visual polarization effect
            neutralParticle.classList.add('polarized-particle');
        }

        function formSubatomicPermanentBond(particle1, particle2) {
            // Mark particles as bonded to each other
            particle1.dataset.bondedTo = particle2.dataset.type;
            particle2.dataset.bondedTo = particle1.dataset.type;
            
            // Stop their individual velocities
            particle1.velocity = {x: 0, y: 0};
            particle2.velocity = {x: 0, y: 0};
            
            // Position them close together
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            const playgroundRect = subatomicPlaygroundArea.getBoundingClientRect();
            
            const centerX = ((rect1.left + rect1.width/2) + (rect2.left + rect2.width/2)) / 2 - playgroundRect.left;
            const centerY = ((rect1.top + rect1.height/2) + (rect2.top + rect2.height/2)) / 2 - playgroundRect.top;
            
            // Position particles 45px apart (touching distance)
            particle1.style.left = (centerX - 22.5) + 'px';
            particle1.style.top = centerY + 'px';
            particle2.style.left = (centerX + 22.5) + 'px';
            particle2.style.top = centerY + 'px';
            
            // Add visual bond indicator
            particle1.classList.add('bonded-particle');
            particle2.classList.add('bonded-particle');
            
            // Create bond line between particles
            createSubatomicBondLine(particle1, particle2);
        }

        function maintainSubatomicBond(particle1, particle2) {
            // Keep bonded particles at a fixed distance from each other
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            const playgroundRect = subatomicPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const currentDistance = Math.sqrt((centerX2 - centerX1) ** 2 + (centerY2 - centerY1) ** 2);
            const targetDistance = 45; // Fixed bond distance
            
            if (Math.abs(currentDistance - targetDistance) > 5) {
                // Adjust positions to maintain bond distance
                const midX = (centerX1 + centerX2) / 2;
                const midY = (centerY1 + centerY2) / 2;
                
                const angle = Math.atan2(centerY2 - centerY1, centerX2 - centerX1);
                
                particle1.style.left = (midX - (targetDistance / 2) * Math.cos(angle) - 25) + 'px';
                particle1.style.top = (midY - (targetDistance / 2) * Math.sin(angle) - 25) + 'px';
                particle2.style.left = (midX + (targetDistance / 2) * Math.cos(angle) - 25) + 'px';
                particle2.style.top = (midY + (targetDistance / 2) * Math.sin(angle) - 25) + 'px';
            }
            
            // Move bonded pair together with slight random motion
            if (!particle1.dataset.bondLeader) {
                particle1.dataset.bondLeader = 'true';
                
                const sharedVelocity = {
                    x: (Math.random() - 0.5) * 0.5,
                    y: (Math.random() - 0.5) * 0.5
                };
                
                particle1.velocity = sharedVelocity;
                particle2.velocity = sharedVelocity;
            }
        }

        function createSubatomicBondLine(particle1, particle2) {
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            
            // Remove any existing bond line for these particles
            const existingBonds = subatomicPlaygroundArea.querySelectorAll('.bond-line');
            existingBonds.forEach(bond => {
                if (bond.dataset.particle1 === particle1.dataset.type || bond.dataset.particle2 === particle2.dataset.type) {
                    bond.remove();
                }
            });
            
            const bondLine = document.createElement('div');
            bondLine.className = 'bond-line';
            bondLine.dataset.particle1 = particle1.dataset.type;
            bondLine.dataset.particle2 = particle2.dataset.type;
            
            bondLine.style.cssText = `
                position: absolute;
                height: 4px;
                background: linear-gradient(to right, #32CD32, #FFD700, #32CD32);
                border-radius: 2px;
                z-index: 5;
                animation: bondGlow 2s ease-in-out infinite;
                box-shadow: 0 0 10px #32CD32;
            `;
            
            // Position the bond line between particles
            updateSubatomicBondLinePosition(bondLine, particle1, particle2);
            
            subatomicPlaygroundArea.appendChild(bondLine);
            
            // Store reference to bond line in particles
            particle1.bondLine = bondLine;
            particle2.bondLine = bondLine;
        }

        function updateSubatomicBondLinePosition(bondLine, particle1, particle2) {
            const rect1 = particle1.getBoundingClientRect();
            const rect2 = particle2.getBoundingClientRect();
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            const playgroundRect = subatomicPlaygroundArea.getBoundingClientRect();
            
            const centerX1 = rect1.left + rect1.width / 2 - playgroundRect.left;
            const centerY1 = rect1.top + rect1.height / 2 - playgroundRect.top;
            const centerX2 = rect2.left + rect2.width / 2 - playgroundRect.left;
            const centerY2 = rect2.top + rect2.height / 2 - playgroundRect.top;
            
            const length = Math.sqrt((centerX2 - centerX1) ** 2 + (centerY2 - centerY1) ** 2);
            const angle = Math.atan2(centerY2 - centerY1, centerX2 - centerX1) * 180 / Math.PI;
            
            bondLine.style.width = length + 'px';
            bondLine.style.left = centerX1 + 'px';
            bondLine.style.top = (centerY1 - 2) + 'px';
            bondLine.style.transform = `rotate(${angle}deg)`;
            bondLine.style.transformOrigin = '0 50%';
        }

        function removeSubatomicSimulationParticle(particle) {
            // Remove from tracking array
            const index = subatomicSimulationParticles.indexOf(particle);
            if (index > -1) {
                subatomicSimulationParticles.splice(index, 1);
            }
            
            // Remove particle with animation
            particle.style.animation = 'dropAnimation 0.3s ease-out reverse';
            setTimeout(() => {
                particle.remove();
                
                // Reset playground if empty
                if (subatomicSimulationParticles.length === 0) {
                    clearSubatomicSimulation();
                }
            }, 300);
        }

        function removeRealWorldSimulationParticle(particle) {
            // Remove from tracking array
            const index = realWorldSimulationParticles.indexOf(particle);
            if (index > -1) {
                realWorldSimulationParticles.splice(index, 1);
            }
            
            // Remove particle with animation
            particle.style.animation = 'dropAnimation 0.3s ease-out reverse';
            setTimeout(() => {
                particle.remove();
                
                // Reset playground if empty
                if (realWorldSimulationParticles.length === 0) {
                    clearRealWorldSimulation();
                }
            }, 300);
        }

        function clearSubatomicSimulation() {
            const subatomicPlaygroundArea = document.getElementById('subatomicPlaygroundArea');
            
            // Stop continuous simulation
            stopSubatomicSimulation();
            updateSubatomicToggleButton();
            
            // Clear all particles
            subatomicSimulationParticles.forEach(particle => {
                particle.style.animation = 'dropAnimation 0.3s ease-out reverse';
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.remove();
                    }
                }, 300);
            });
            
            // Clear interaction lines, bond lines, and explanations
            const interactionElements = subatomicPlaygroundArea.querySelectorAll('.interaction-line, .interaction-explanation, .bond-line');
            interactionElements.forEach(element => element.remove());
            
            // Reset tracking array
            subatomicSimulationParticles = [];
            
            // Reset playground content
            setTimeout(() => {
                subatomicPlaygroundArea.innerHTML = `
                    <div style="color: #FFD700; font-style: italic; text-align: center; padding: 3rem;">
                        üéØ Drag protons and electrons here to see charge interactions!<br>
                        <span style="color: #FF6B6B; font-size: 0.9rem;">‚Ä¢ Two protons REPEL (push apart continuously)</span><br>
                        <span style="color: #87CEEB; font-size: 0.9rem;">‚Ä¢ Two electrons REPEL (push apart continuously)</span><br>
                        <span style="color: #32CD32; font-size: 0.9rem;">‚Ä¢ Proton and electron ATTRACT ‚Üí PERMANENT BOND!</span><br>
                        <span style="color: #FFD700; font-size: 0.8rem;">üí° Once bonded, the pair becomes NEUTRAL and ignores other particles!</span>
                    </div>
                `;
            }, 400);
        }

        function clearRealWorldSimulation() {
            const realWorldPlaygroundArea = document.getElementById('realWorldPlaygroundArea');
            
            // Stop continuous simulation
            stopRealWorldSimulation();
            updateRealWorldToggleButton();
            
            // Clear all particles
            realWorldSimulationParticles.forEach(particle => {
                particle.style.animation = 'dropAnimation 0.3s ease-out reverse';
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.remove();
                    }
                }, 300);
            });
            
            // Clear interaction lines and explanations
            const interactionElements = realWorldPlaygroundArea.querySelectorAll('.interaction-line, .interaction-explanation');
            interactionElements.forEach(element => element.remove());
            
            // Reset tracking array
            realWorldSimulationParticles = [];
            
            // Reset playground content
            setTimeout(() => {
                realWorldPlaygroundArea.innerHTML = `
                    <div style="color: #FFD700; font-style: italic; text-align: center; padding: 3rem;">
                        üåç Drag real objects here to see electrostatic interactions!<br>
                        <span style="color: #FF6B6B; font-size: 0.9rem;">‚Ä¢ Like charges REPEL (balloon vs comb)</span><br>
                        <span style="color: #32CD32; font-size: 0.9rem;">‚Ä¢ Unlike charges ATTRACT (balloon vs hair)</span><br>
                        <span style="color: #87CEEB; font-size: 0.9rem;">‚Ä¢ Neutral objects get POLARIZED and attracted</span><br>
                        <span style="color: #FFD700; font-size: 0.8rem;">üí° See how static electricity works in everyday life!</span>
                    </div>
                `;
            }, 400);
        }

        // Subatomic Particle Demonstration Functions
        function showSubatomicRepulsion(type) {
            const demoArea = document.getElementById('repelDemo');
            demoArea.innerHTML = '';
            
            if (type === 'proton-proton') {
                // Create two protons
                const proton1 = createSubatomicParticle('proton', '+', 80, 100);
                const proton2 = createSubatomicParticle('proton', '+', 160, 100);
                
                proton1.style.setProperty('--repel-distance', '-50px');
                proton2.style.setProperty('--repel-distance', '50px');
                
                demoArea.appendChild(proton1);
                demoArea.appendChild(proton2);
                
                // Add force field visualization
                const forceField = createForceField(120, 100, 100, 'repulsion');
                demoArea.appendChild(forceField);
                
                // Start animation
                setTimeout(() => {
                    proton1.classList.add('repelling-particle');
                    proton2.classList.add('repelling-particle');
                }, 500);
                
                // Add explanation
                addParticleExplanation(demoArea, 'Two protons REPEL each other!', 'Both have positive charge (+1.6√ó10‚Åª¬π‚Åπ C)', '#FF6B6B');
                
            } else if (type === 'electron-electron') {
                // Create two electrons
                const electron1 = createSubatomicParticle('electron', '-', 80, 100);
                const electron2 = createSubatomicParticle('electron', '-', 160, 100);
                
                electron1.style.setProperty('--repel-distance', '-50px');
                electron2.style.setProperty('--repel-distance', '50px');
                
                demoArea.appendChild(electron1);
                demoArea.appendChild(electron2);
                
                // Add force field visualization
                const forceField = createForceField(120, 100, 100, 'repulsion');
                demoArea.appendChild(forceField);
                
                // Start animation
                setTimeout(() => {
                    electron1.classList.add('repelling-particle');
                    electron2.classList.add('repelling-particle');
                }, 500);
                
                // Add explanation
                addParticleExplanation(demoArea, 'Two electrons REPEL each other!', 'Both have negative charge (-1.6√ó10‚Åª¬π‚Åπ C)', '#87CEEB');
            }
        }

        function showSubatomicAttraction(type) {
            const demoArea = document.getElementById('attractDemo');
            demoArea.innerHTML = '';
            
            if (type === 'proton-electron') {
                // Create proton and electron
                const proton = createSubatomicParticle('proton', '+', 80, 100);
                const electron = createSubatomicParticle('electron', '-', 160, 100);
                
                proton.style.setProperty('--attract-distance', '25px');
                electron.style.setProperty('--attract-distance', '-25px');
                
                demoArea.appendChild(proton);
                demoArea.appendChild(electron);
                
                // Add force field visualization
                const forceField = createForceField(120, 100, 100, 'attraction');
                demoArea.appendChild(forceField);
                
                // Start animation
                setTimeout(() => {
                    proton.classList.add('attracting-particle');
                    electron.classList.add('attracting-particle');
                }, 500);
                
                // Add explanation
                addParticleExplanation(demoArea, 'Proton and Electron ATTRACT!', 'Opposite charges create attractive force', '#32CD32');
                
                // Add orbital simulation after 3 seconds
                setTimeout(() => {
                    simulateElectronOrbitSubatomic(demoArea, proton, electron);
                }, 3000);
                
            } else if (type === 'ion-interaction') {
                // Create positive and negative ions
                const positiveIon = createSubatomicParticle('positive-ion', '+', 80, 100);
                const negativeIon = createSubatomicParticle('negative-ion', '-', 160, 100);
                
                positiveIon.style.setProperty('--attract-distance', '30px');
                negativeIon.style.setProperty('--attract-distance', '-30px');
                
                demoArea.appendChild(positiveIon);
                demoArea.appendChild(negativeIon);
                
                // Add force field visualization
                const forceField = createForceField(120, 100, 120, 'attraction');
                demoArea.appendChild(forceField);
                
                // Start animation
                setTimeout(() => {
                    positiveIon.classList.add('attracting-particle');
                    negativeIon.classList.add('attracting-particle');
                }, 500);
                
                // Add explanation
                addParticleExplanation(demoArea, 'Positive and Negative Ions ATTRACT!', 'Forms ionic bonds in compounds like NaCl', '#32CD32');
            }
        }

        function createSubatomicParticle(type, charge, x, y) {
            const particle = document.createElement('div');
            particle.className = `subatomic-particle ${type}`;
            particle.innerHTML = charge;
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.dataset.charge = charge;
            particle.dataset.type = type;
            return particle;
        }

        function createForceField(x, y, size, type) {
            const field = document.createElement('div');
            field.className = `force-field ${type}`;
            field.style.left = (x - size/2) + 'px';
            field.style.top = (y - size/2) + 'px';
            field.style.width = size + 'px';
            field.style.height = size + 'px';
            return field;
        }

        function addParticleExplanation(container, title, description, color) {
            const explanation = document.createElement('div');
            explanation.style.cssText = `
                position: absolute;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                padding: 1rem;
                border-radius: 8px;
                border: 2px solid ${color};
                text-align: center;
                max-width: 90%;
            `;
            explanation.innerHTML = `
                <div style="color: ${color}; font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem;">${title}</div>
                <div style="color: white; font-size: 0.9rem;">${description}</div>
            `;
            container.appendChild(explanation);
        }

        function simulateElectronOrbitSubatomic(container, proton, electron) {
            // Clear existing animations
            proton.classList.remove('attracting-particle');
            electron.classList.remove('attracting-particle');
            
            // Create orbital path
            const orbitPath = document.createElement('div');
            orbitPath.style.cssText = `
                position: absolute;
                width: 120px;
                height: 120px;
                border: 2px dashed #87CEEB;
                border-radius: 50%;
                left: 60px;
                top: 40px;
                opacity: 0.5;
            `;
            container.appendChild(orbitPath);
            
            // Animate electron in orbit around proton
            let angle = 0;
            const centerX = 120;
            const centerY = 100;
            const radius = 50;
            
            const orbitAnimation = setInterval(() => {
                angle += 0.15;
                const x = centerX + radius * Math.cos(angle) - 25;
                const y = centerY + radius * Math.sin(angle) - 25;
                
                electron.style.left = x + 'px';
                electron.style.top = y + 'px';
                
                // Stop after a few orbits
                if (angle > 6 * Math.PI) {
                    clearInterval(orbitAnimation);
                }
            }, 50);
            
            // Update explanation
            setTimeout(() => {
                const explanation = container.querySelector('div[style*="bottom: 10px"]');
                if (explanation) {
                    explanation.innerHTML = `
                        <div style="color: #87CEEB; font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem;">Electron orbits the proton!</div>
                        <div style="color: white; font-size: 0.9rem;">This forms a hydrogen atom ‚öõÔ∏è</div>
                    `;
                }
            }, 1000);
        }

        // Charging method navigation
        function showChargingMethod(methodId) {
            // Hide all charging method sections
            const sections = document.querySelectorAll('.charging-method-section');
            sections.forEach(section => section.style.display = 'none');
            
            // Show selected section
            document.getElementById(methodId).style.display = 'block';
            
            // Update navigation buttons
            const navButtons = document.querySelectorAll('.charging-method-btn');
            navButtons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Reinitialize drag and drop for the new section
            setTimeout(() => {
                setupDragAndDrop();
            }, 100);
        }

        function handleChargingDrop(type, originalItem) {
            const activeMethod = document.querySelector('.charging-method-section:not([style*="display: none"])');
            const methodId = activeMethod ? activeMethod.id : 'rubbing';
            
            switch(methodId) {
                case 'rubbing':
                    handleRubbingDrop(type, originalItem);
                    break;
                case 'conduction':
                    handleConductionDrop(type, originalItem);
                    break;
                case 'induction':
                    handleInductionDropMaster(type, originalItem);
                    break;
                    break;
            }
        }

        function handleRubbingDrop(type, originalItem) {
            // Create simulation object in the simulation area
            const simulationArea = document.getElementById('simulationArea');
            const objectData = getObjectData(type);
            const triboelectric = parseInt(originalItem.getAttribute('data-triboelectric'));
            
            // Initialize tracking array if needed
            if (!simulationArea.droppedItems) {
                simulationArea.droppedItems = [];
            }
            
            // Clear placeholder text if this is the first object
            if (simulationArea.droppedItems.length === 0) {
                simulationArea.innerHTML = '';
            }
            
            // Create simulation object
            const simObject = document.createElement('div');
            simObject.className = 'simulation-object';
            simObject.dataset.type = type;
            simObject.dataset.triboelectric = triboelectric;
            simObject.draggable = true;

            // If the original sidebar item provides its own icon/name, prefer that
            const extracted = extractIconNameFromElement(originalItem);
            const iconHtml = extracted.icon || objectData.icon;
            const nameText = extracted.name || objectData.name;

            simObject.innerHTML = `
                <div class="object-icon">${iconHtml}</div>
                <div class="object-name">${nameText}</div>
                <div class="charge-indicator" style="display: none;"></div>
                <button class="remove-btn" onclick="removeSimulationObject(this.parentElement, '${type}')">√ó</button>
            `;
            
            // Make the simulation object draggable within the simulation area
            setupSimulationObjectDrag(simObject);
            
            simulationArea.appendChild(simObject);
            
            // Add to tracking array
            simulationArea.droppedItems.push({
                element: simObject,
                type: type,
                triboelectric: triboelectric
            });
            
            // Objects are now ready for manual rubbing - no automatic animation
        }

        function getObjectData(type) {
            const objectMap = {
                'cat-fur': {
                    name: 'Cat Fur',
                    icon: 'üê±',
                    gradient: 'linear-gradient(145deg, #D2691E, #8B4513)',
                    material: 'Natural Fur'
                },
                'glass-rod': {
                    name: 'Glass Rod',
                    icon: 'üî¨',
                    gradient: 'linear-gradient(145deg, #E6E6FA, #D8BFD8)',
                    material: 'Glass'
                },
                'human-hair': {
                    name: 'Human Hair',
                    icon: 'üíá‚Äç‚ôÄÔ∏è',
                    gradient: 'linear-gradient(145deg, #8B4513, #654321)',
                    material: 'Keratin'
                },
                'nylon-fabric': {
                    name: 'Nylon Fabric',
                    icon: 'üß∂',
                    gradient: 'linear-gradient(145deg, #E0E0E0, #C0C0C0)',
                    material: 'Synthetic Nylon'
                },
                'wool-sweater': {
                    name: 'Wool Sweater',
                    icon: 'üß•',
                    gradient: 'linear-gradient(145deg, #DEB887, #CD853F)',
                    material: 'Natural Wool'
                },
                'silk-cloth': {
                    name: 'Silk Cloth',
                    icon: 'üßµ',
                    gradient: 'linear-gradient(145deg, #F0E68C, #DAA520)',
                    material: 'Natural Silk'
                },
                'aluminum-foil': {
                    name: 'Aluminum Foil',
                    icon: 'üìÑ',
                    gradient: 'linear-gradient(145deg, #C0C0C0, #A9A9A9)',
                    material: 'Metal'
                },
                'paper-towel': {
                    name: 'Paper Towel',
                    icon: 'üßª',
                    gradient: 'linear-gradient(145deg, #F5F5DC, #E6E6FA)',
                    material: 'Paper Fiber'
                },
                'cotton-shirt': {
                    name: 'Cotton T-Shirt',
                    icon: 'üëï',
                    gradient: 'linear-gradient(145deg, #87CEEB, #4682B4)',
                    material: 'Natural Cotton'
                },
                'wooden-ruler': {
                    name: 'Wooden Ruler',
                    icon: 'üìè',
                    gradient: 'linear-gradient(145deg, #DEB887, #8B7355)',
                    material: 'Dry Wood'
                },
                'plastic-pen': {
                    name: 'Plastic Pen',
                    icon: 'üñäÔ∏è',
                    gradient: 'linear-gradient(145deg, #4169E1, #0000CD)',
                    material: 'Hard Plastic'
                },
                'plastic-comb': {
                    name: 'Plastic Comb',
                    icon: 'üíá',
                    gradient: 'linear-gradient(145deg, #FFB6C1, #FF69B4)',
                    material: 'Hard Plastic'
                },
                'polyester-fabric': {
                    name: 'Polyester Fabric',
                    icon: 'üßµ',
                    gradient: 'linear-gradient(145deg, #DA70D6, #BA55D3)',
                    material: 'Synthetic Polyester'
                },
                'styrofoam-cup': {
                    name: 'Styrofoam Cup',
                    icon: 'ü•§',
                    gradient: 'linear-gradient(145deg, #F5F5F5, #DCDCDC)',
                    material: 'Polystyrene'
                },
                'plastic-wrap': {
                    name: 'Plastic Wrap',
                    icon: 'üì¶',
                    gradient: 'linear-gradient(145deg, #F0F8FF, #E6E6FA)',
                    material: 'Thin Plastic'
                },
                'rubber-balloon': {
                    name: 'Rubber Balloon',
                    icon: 'üéà',
                    gradient: 'linear-gradient(145deg, #FF4500, #FF6347)',
                    material: 'Latex Rubber'
                },
                'vinyl-record': {
                    name: 'Vinyl Record',
                    icon: 'üíø',
                    gradient: 'linear-gradient(145deg, #2F4F4F, #000000)',
                    material: 'PVC Vinyl'
                },
                'rubber-shoes': {
                    name: 'Rubber Shoes',
                    icon: 'üëü',
                    gradient: 'linear-gradient(145deg, #696969, #2F4F4F)',
                    material: 'Rubber Sole'
                },
                'carpet-fabric': {
                    name: 'Carpet',
                    icon: 'üè†',
                    gradient: 'linear-gradient(145deg, #8B4513, #A0522D)',
                    material: 'Synthetic Fiber'
                },
                'teflon-pan': {
                    name: 'Teflon Pan',
                    icon: 'üç≥',
                    gradient: 'linear-gradient(145deg, #2F4F4F, #000000)',
                    material: 'PTFE Coating'
                }
            };
            
            return objectMap[type] || {name: 'Unknown', icon: '‚ùì', gradient: 'linear-gradient(145deg, #CCC, #999)', material: 'Unknown'};
        }

        function setupSimulationObjectDrag(simObject) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            simObject.addEventListener('mousedown', function(e) {
                // Don't start drag if clicking on remove button
                if (e.target.classList.contains('remove-btn')) {
                    return;
                }
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = simObject.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                simObject.style.cursor = 'grabbing';
                simObject.style.zIndex = '1000';
                simObject.style.transform = 'scale(1.05)';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const newX = initialX + deltaX;
                const newY = initialY + deltaY;
                
                // Keep object within simulation area bounds
                const simulationArea = document.getElementById('simulationArea');
                const simRect = simulationArea.getBoundingClientRect();
                const objRect = simObject.getBoundingClientRect();
                
                const minX = simRect.left;
                const maxX = simRect.right - objRect.width;
                const minY = simRect.top;
                const maxY = simRect.bottom - objRect.height;
                
                const boundedX = Math.max(minX, Math.min(maxX, newX));
                const boundedY = Math.max(minY, Math.min(maxY, newY));
                
                simObject.style.position = 'absolute';
                simObject.style.left = (boundedX - simRect.left) + 'px';
                simObject.style.top = (boundedY - simRect.top) + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (!isDragging) return;
                
                isDragging = false;
                simObject.style.cursor = 'grab';
                simObject.style.zIndex = 'auto';
                simObject.style.transform = 'scale(1)';
                
                // Check for collisions with other objects for rubbing effect
                checkForRubbingCollision(simObject);
                
                // Check if objects are separated after dragging
                setTimeout(() => {
                    checkForSeparation(simObject);
                }, 100);
            });
            
            // Touch events for mobile
            simObject.addEventListener('touchstart', function(e) {
                if (e.target.classList.contains('remove-btn')) {
                    return;
                }
                
                isDragging = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
                
                const rect = simObject.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                simObject.style.cursor = 'grabbing';
                simObject.style.zIndex = '1000';
                simObject.style.transform = 'scale(1.05)';
                
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                
                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;
                
                const newX = initialX + deltaX;
                const newY = initialY + deltaY;
                
                const simulationArea = document.getElementById('simulationArea');
                const simRect = simulationArea.getBoundingClientRect();
                const objRect = simObject.getBoundingClientRect();
                
                const minX = simRect.left;
                const maxX = simRect.right - objRect.width;
                const minY = simRect.top;
                const maxY = simRect.bottom - objRect.height;
                
                const boundedX = Math.max(minX, Math.min(maxX, newX));
                const boundedY = Math.max(minY, Math.min(maxY, newY));
                
                simObject.style.position = 'absolute';
                simObject.style.left = (boundedX - simRect.left) + 'px';
                simObject.style.top = (boundedY - simRect.top) + 'px';
                
                e.preventDefault();
            });
            
            document.addEventListener('touchend', function() {
                if (!isDragging) return;
                
                isDragging = false;
                simObject.style.cursor = 'grab';
                simObject.style.zIndex = 'auto';
                simObject.style.transform = 'scale(1)';
                
                checkForRubbingCollision(simObject);
                
                // Check if objects are separated after dragging
                setTimeout(() => {
                    checkForSeparation(simObject);
                }, 100);
            });
            
            // Set initial cursor
            simObject.style.cursor = 'grab';
        }
        
        function checkForRubbingCollision(draggedObject) {
            const simulationArea = document.getElementById('simulationArea');
            const allObjects = simulationArea.querySelectorAll('.simulation-object');
            
            const draggedRect = draggedObject.getBoundingClientRect();
            
            allObjects.forEach(otherObject => {
                if (otherObject === draggedObject) return;
                
                const otherRect = otherObject.getBoundingClientRect();
                
                // Check if objects are overlapping or very close
                const distance = Math.sqrt(
                    Math.pow(draggedRect.left - otherRect.left, 2) + 
                    Math.pow(draggedRect.top - otherRect.top, 2)
                );
                
                if (distance < 80) { // Objects are close enough for continuous rubbing
                    triggerContinuousRubbingEffect(draggedObject, otherObject);
                }
            });
        }
        
        function triggerContinuousRubbingEffect(obj1, obj2) {
            // Create unique pair identifier
            const pairId = [obj1.dataset.type, obj2.dataset.type].sort().join('-');
            
            // Check if this pair is already being rubbed
            if (obj1.dataset.rubbingWith === obj2.dataset.type || obj2.dataset.rubbingWith === obj1.dataset.type) {
                return; // Already rubbing together
            }
            
            // If objects are same material or identical type, do NOT transfer charge
            if (objectsSameMaterial(obj1, obj2)) {
                const sim = document.getElementById('simulationArea');
                showPhysicsInfoMessage(sim, 'No net charge transfer occurs because both objects have the same electron affinity.');
                return;
            }

            // Mark objects as rubbing together
            obj1.dataset.rubbingWith = obj2.dataset.type;
            obj2.dataset.rubbingWith = obj1.dataset.type;
            
            // Add continuous rubbing animation
            obj1.classList.add('rubbing-animation');
            obj2.classList.add('rubbing-animation');
            
            // Get triboelectric values to determine which loses electrons
            const triboelectric1 = parseInt(obj1.dataset.triboelectric);
            const triboelectric2 = parseInt(obj2.dataset.triboelectric);
            
            let positiveObject, negativeObject; // positive = loses electrons, negative = gains electrons
            
            if (triboelectric1 < triboelectric2) {
                positiveObject = obj1; // loses electrons (becomes positive)
                negativeObject = obj2; // gains electrons (becomes negative)
            } else {
                positiveObject = obj2; // loses electrons (becomes positive)
                negativeObject = obj1; // gains electrons (becomes negative)
            }
            
            // Start continuous rubbing process
            startContinuousRubbing(positiveObject, negativeObject, pairId);
            try { soundManager.playRub(); } catch(e){}
        }
        
        function startContinuousRubbing(positiveObject, negativeObject, pairId) {
            // Show immediate sparking effect
            createRubbingSparks(positiveObject, negativeObject);
            
            // Start electron transfer after brief rubbing
            setTimeout(() => {
                if (positiveObject.dataset.rubbingWith && negativeObject.dataset.rubbingWith) {
                    showContinuousElectronTransfer(positiveObject, negativeObject);
                    updateChargeIndicators(positiveObject, negativeObject);
                    
                    // Show results after electron transfer
                    setTimeout(() => {
                        if (positiveObject.dataset.rubbingWith && negativeObject.dataset.rubbingWith) {
                            displayRubbingResults({element: positiveObject, type: positiveObject.dataset.type}, {element: negativeObject, type: negativeObject.dataset.type});
                            
                            // Mark as fully charged
                            positiveObject.dataset.fullyCharged = 'true';
                            negativeObject.dataset.fullyCharged = 'true';
                        }
                    }, 2000);
                }
            }, 800);
        }
        
        function createRubbingSparks(obj1, obj2) {
            const simulationArea = document.getElementById('simulationArea');
            const rect1 = obj1.getBoundingClientRect();
            const rect2 = obj2.getBoundingClientRect();
            const simRect = simulationArea.getBoundingClientRect();
            
            // Calculate contact point between objects
            const contactX = ((rect1.left + rect1.width/2) + (rect2.left + rect2.width/2)) / 2 - simRect.left;
            const contactY = ((rect1.top + rect1.height/2) + (rect2.top + rect2.height/2)) / 2 - simRect.top;
            
            // Create multiple sparks at contact point
            for (let i = 0; i < 8; i++) {
                const spark = document.createElement('div');
                spark.style.cssText = `
                    position: absolute;
                    width: 12px;
                    height: 12px;
                    background: radial-gradient(circle, #FFD700, #FFA500);
                    border-radius: 50%;
                    left: ${contactX + (Math.random() - 0.5) * 30}px;
                    top: ${contactY + (Math.random() - 0.5) * 30}px;
                    box-shadow: 0 0 20px #FFD700;
                    animation: sparkBurst 1s ease-out infinite;
                    z-index: 999;
                `;
                simulationArea.appendChild(spark);
                
                // Remove spark after animation
                setTimeout(() => {
                    if (spark.parentNode) {
                        spark.remove();
                    }
                }, 3000);
            }
        }
        
        function checkForSeparation(draggedObject) {
            const simulationArea = document.getElementById('simulationArea');
            const allObjects = simulationArea.querySelectorAll('.simulation-object');
            
            // Check if this object is currently rubbing with another
            if (!draggedObject.dataset.rubbingWith) {
                return;
            }
            
            const draggedRect = draggedObject.getBoundingClientRect();
            let stillRubbing = false;
            
            allObjects.forEach(otherObject => {
                if (otherObject === draggedObject) return;
                if (otherObject.dataset.type !== draggedObject.dataset.rubbingWith) return;
                
                const otherRect = otherObject.getBoundingClientRect();
                
                // Check distance between objects
                const distance = Math.sqrt(
                    Math.pow(draggedRect.left - otherRect.left, 2) + 
                    Math.pow(draggedRect.top - otherRect.top, 2)
                );
                
                if (distance < 80) {
                    stillRubbing = true;
                }
            });
            
            // If objects are separated, stop rubbing effects
            if (!stillRubbing) {
                stopRubbingEffects(draggedObject);
            }
        }
        
        function stopRubbingEffects(obj) {
            const simulationArea = document.getElementById('simulationArea');
            const allObjects = simulationArea.querySelectorAll('.simulation-object');
            
            // Find the partner object
            const partnerType = obj.dataset.rubbingWith;
            let partnerObject = null;
            
            allObjects.forEach(otherObj => {
                if (otherObj.dataset.type === partnerType && otherObj.dataset.rubbingWith === obj.dataset.type) {
                    partnerObject = otherObj;
                }
            });
            
            // Stop rubbing animations and clear rubbing state
            obj.classList.remove('rubbing-animation');
            delete obj.dataset.rubbingWith;
            
            if (partnerObject) {
                partnerObject.classList.remove('rubbing-animation');
                delete partnerObject.dataset.rubbingWith;
            }
            
            // Clear any remaining sparks
            const sparks = simulationArea.querySelectorAll('[style*="sparkBurst"]');
            sparks.forEach(spark => {
                if (spark.parentNode) {
                    spark.remove();
                }
            });
        }

        function removeSimulationObject(element, type) {
            const simulationArea = document.getElementById('simulationArea');
            
            // Remove from tracking array
            if (simulationArea.droppedItems) {
                simulationArea.droppedItems = simulationArea.droppedItems.filter(item => item.element !== element);
            }
            
            // Remove element with animation
            element.style.animation = 'dropAnimation 0.3s ease-out reverse';
            setTimeout(() => {
                element.remove();
                
                // Reset simulation area if empty
                const simulationArea = document.getElementById('simulationArea');
                if (simulationArea.children.length === 0) {
                    simulationArea.innerHTML = '<div style="color: #FFD700; font-style: italic; font-size: 1.2rem;">Drop objects here to start rubbing simulation</div>';
                    document.getElementById('chargingResults').innerHTML = '';
                    document.getElementById('electronTransferArea').innerHTML = '';
                }
            }, 300);
        }

        // Auto Rub Together Function
        function autoRubTogether() {
            const simulationArea = document.getElementById('simulationArea');
            const allObjects = simulationArea.querySelectorAll('.simulation-object');
            
            // Check if we have at least 2 objects
            if (allObjects.length < 2) {
                const message = document.createElement('div');
                message.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 0, 0, 0.8); color: white; padding: 1rem; border-radius: 8px; z-index: 1000; font-weight: bold;';
                message.textContent = 'Need at least 2 objects to rub together!';
                simulationArea.appendChild(message);
                setTimeout(() => message.remove(), 2000);
                return;
            }
            
            // Find first two objects that aren't already rubbing
            let obj1 = null, obj2 = null;
            
            for (let i = 0; i < allObjects.length && (!obj1 || !obj2); i++) {
                const obj = allObjects[i];
                if (!obj.dataset.rubbingWith) {
                    if (!obj1) {
                        obj1 = obj;
                    } else if (!obj2) {
                        obj2 = obj;
                    }
                }
            }
            
            if (!obj1 || !obj2) {
                const message = document.createElement('div');
                message.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 165, 0, 0.8); color: white; padding: 1rem; border-radius: 8px; z-index: 1000; font-weight: bold;';
                message.textContent = 'All objects are already rubbing together!';
                simulationArea.appendChild(message);
                setTimeout(() => message.remove(), 2000);
                return;
            }
            
            // Position objects close together in center
            const simRect = simulationArea.getBoundingClientRect();
            const centerX = simRect.width / 2 - 60;
            const centerY = simRect.height / 2 - 50;
            
            obj1.style.position = 'absolute';
            obj1.style.left = (centerX - 80) + 'px';
            obj1.style.top = centerY + 'px';
            
            obj2.style.position = 'absolute';
            obj2.style.left = (centerX + 80) + 'px';
            obj2.style.top = centerY + 'px';
            
            // Start rubbing effect
            setTimeout(() => {
                triggerContinuousRubbingEffect(obj1, obj2);
                try { soundManager.playRub(); } catch(e){}
            }, 500);
        }

        function showContinuousElectronTransfer(positiveObject, negativeObject) {
            // CRITICAL: Electrons flow FROM the object that LOSES electrons (becomes positive) TO the object that GAINS electrons (becomes negative)
            const fromRect = positiveObject.getBoundingClientRect(); // Object that LOSES electrons
            const toRect = negativeObject.getBoundingClientRect();   // Object that GAINS electrons
            const simulationArea = document.getElementById('simulationArea');
            const simRect = simulationArea.getBoundingClientRect();
            
            // Calculate positions relative to simulation area
            const startX = (fromRect.left + fromRect.width/2) - simRect.left;
            const startY = (fromRect.top + fromRect.height/2) - simRect.top;
            const endX = (toRect.left + toRect.width/2) - simRect.left;
            const endY = (toRect.top + toRect.height/2) - simRect.top;
            
            // Create continuous stream of electrons flowing from positive to negative object
            try { soundManager.playSpark(); } catch(e){}
            let electronCount = 0;
            const maxElectrons = 20;
            
            const electronInterval = setInterval(() => {
                if (electronCount >= maxElectrons || !positiveObject.dataset.rubbingWith) {
                    clearInterval(electronInterval);
                    return;
                }
                
                const electron = document.createElement('div');
                electron.className = 'electron-transfer-particle';
                
                // Style the electron particle
                electron.style.cssText = `
                    position: absolute;
                    width: 14px;
                    height: 14px;
                    background: radial-gradient(circle, #87CEEB, #4682B4);
                    border-radius: 50%;
                    box-shadow: 0 0 15px #87CEEB, 0 0 25px #4682B4;
                    left: ${startX}px;
                    top: ${startY}px;
                    z-index: 1000;
                `;
                
                simulationArea.appendChild(electron);
                
                // Animate electron from positive object to negative object
                let progress = 0;
                const animationSpeed = 0.02;
                
                const moveElectron = () => {
                    progress += animationSpeed;
                    
                    if (progress >= 1) {
                        // Electron reached destination
                        electron.style.opacity = '0';
                        setTimeout(() => {
                            if (electron.parentNode) {
                                electron.remove();
                            }
                        }, 200);
                        return;
                    }
                    
                    // Calculate current position along the path
                    const currentX = startX + (endX - startX) * progress;
                    const currentY = startY + (endY - startY) * progress;
                    
                    // Add slight curve to the path for more realistic movement
                    const curve = Math.sin(progress * Math.PI) * 20;
                    
                    electron.style.left = currentX + 'px';
                    electron.style.top = (currentY + curve) + 'px';
                    
                    // Scale electron as it moves
                    const scale = 1 + Math.sin(progress * Math.PI) * 0.3;
                    electron.style.transform = `scale(${scale})`;
                    
                    requestAnimationFrame(moveElectron);
                };
                
                requestAnimationFrame(moveElectron);
                electronCount++;
            }, 150); // New electron every 150ms for continuous flow
            
            // Add PERMANENT transfer label showing the direction
            const transferArea = document.getElementById('electronTransferArea');
            
            // Clear any existing labels first
            transferArea.innerHTML = '';
            
            const label = document.createElement('div');
            label.style.cssText = 'text-align: center; color: #87CEEB; font-weight: bold; font-size: 1.2rem; animation: pulse 2s ease-in-out infinite; background: rgba(0,0,0,0.6); padding: 1rem; border-radius: 8px; border: 1px solid #87CEEB;';
            
            const posName = positiveObject.querySelector('.object-name').textContent;
            const negName = negativeObject.querySelector('.object-name').textContent;
            
            label.innerHTML = `
                ‚ö° ELECTRONS FLOWING! ‚ö°<br>
                <span style="color: #FFD700; font-size: 0.9rem;">
                    FROM: ${posName} (loses e‚Åª) ‚Üí TO: ${negName} (gains e‚Åª)
                </span><br>
                <span style="color: #87CEEB; font-size: 0.8rem;">Watch the blue particles move from positive to negative!</span>
            `;
            transferArea.appendChild(label);
            
            // Keep the label permanently - don't remove it
        }

        function updateChargeIndicators(positiveElement, negativeElement) {
            // Show positive charge indicator
            const posIndicator = positiveElement.querySelector('.charge-indicator');
            posIndicator.style.display = 'flex';
            posIndicator.className = 'charge-indicator positive';
            posIndicator.innerHTML = '+';
            
            // Show negative charge indicator
            const negIndicator = negativeElement.querySelector('.charge-indicator');
            negIndicator.style.display = 'flex';
            negIndicator.className = 'charge-indicator negative';
            negIndicator.innerHTML = '-';
        }

        function displayRubbingResults(positiveObject, negativeObject) {
            const resultsArea = document.getElementById('chargingResults');
            
            const posName = positiveObject.element.querySelector('.object-name').textContent;
            const negName = negativeObject.element.querySelector('.object-name').textContent;
            
            resultsArea.innerHTML = `
                <div style="background: rgba(255, 215, 0, 0.1); border-radius: 10px; padding: 1.5rem; border: 1px solid #FFD700;">
                    <h4 style="color: #FFD700; margin-bottom: 1rem;">‚ö° Rubbing Results:</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                        <div style="text-align: center;">
                            <div style="color: #FF6B6B; font-weight: bold; font-size: 1.2rem;">POSITIVE (+)</div>
                            <div style="color: white;">${posName}</div>
                            <div style="color: #FFD700; font-size: 0.9rem;">Lost electrons</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #87CEEB; font-weight: bold; font-size: 1.2rem;">NEGATIVE (-)</div>
                            <div style="color: white;">${negName}</div>
                            <div style="color: #FFD700; font-size: 0.9rem;">Gained electrons</div>
                        </div>
                    </div>
                    <div style="color: #32CD32; text-align: center; font-weight: bold;">
                        üí° Real Example: ${getRealWorldExample(positiveObject.type, negativeObject.type)}
                    </div>
                </div>
            `;
        }

        function getRealWorldExample(posType, negType) {
            const examples = {
                'rubber-balloon_human-hair': 'Balloon sticks to hair after rubbing - static electricity!',
                'plastic-comb_human-hair': 'Comb attracts small paper pieces after combing hair',
                'wool-sweater_plastic-comb': 'Static shock when removing synthetic clothes from dryer',
                'silk-cloth_rubber-balloon': 'Balloon sticks to silk fabric after rubbing',
                'fur-coat_plastic-comb': 'Pet fur sticks to plastic brush after grooming',
                'glass-rod_silk-cloth': 'Classic electrostatics demonstration in physics labs',
                'paper-pieces_plastic-comb': 'Paper bits jump to charged comb - electrostatic attraction'
            };
            
            const key1 = `${posType}_${negType}`;
            const key2 = `${negType}_${posType}`;
            
            return examples[key1] || examples[key2] || 'Objects will attract small neutral particles and each other!';
        }

        function handleConductionSimulationDrop(event, draggedItem) {
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            const objectType = draggedItem.getAttribute('data-type');
            const chargeType = draggedItem.getAttribute('data-charge');
            
            // Clear placeholder text if this is the first object
            if (!conductionSimulationArea.droppedItems) {
                conductionSimulationArea.droppedItems = [];
            }
            
            if (conductionSimulationArea.droppedItems.length === 0) {
                conductionSimulationArea.innerHTML = '';
            }
            
            // Get drop position relative to conduction simulation area
            const rect = conductionSimulationArea.getBoundingClientRect();
            const x = event.clientX - rect.left - 30; // Center the object
            const y = event.clientY - rect.top - 30;
            
            // Create object in conduction simulation
            const simObject = createConductionSimulationObject(objectType, chargeType, x, y);
            conductionSimulationArea.appendChild(simObject);
            
            // Add to tracking array
            conductionSimulationArea.droppedItems.push({
                element: simObject,
                type: objectType,
                charge: chargeType,
                originalCharge: chargeType
            });
            
            // Setup dragging within conduction simulation
            setupConductionObjectDrag(simObject);
        }

        function createConductionSimulationObject(type, charge, x, y) {
            const simObject = document.createElement('div');
            simObject.className = 'simulation-object';
            simObject.dataset.type = type;
            simObject.dataset.charge = charge;
            simObject.dataset.originalCharge = charge;
            simObject.style.left = Math.max(0, Math.min(x, 500)) + 'px';
            simObject.style.top = Math.max(0, Math.min(y, 320)) + 'px';
            
            // Set object content and properties based on type
            const objectData = getConductionObjectData(type);
            simObject.innerHTML = `
                <div class="object-icon">${objectData.icon}</div>
                <div class="object-name">${objectData.name}</div>
                <div class="charge-indicator" style="display: ${charge !== 'neutral' ? 'flex' : 'none'};">${getChargeSymbol(charge)}</div>
                <button class="remove-btn" onclick="removeConductionObject(this.parentElement, '${type}')">√ó</button>
            `;
            
            // Set initial charge appearance
            updateConductionObjectAppearance(simObject, charge);
            
            return simObject;
        }

        function handleInductionDrop(element, type, originalItem) {
            const inductionResult = document.getElementById('inductionResult');
            const fieldViz = document.getElementById('fieldViz');
            
            if (!inductionResult.droppedItems) {
                inductionResult.droppedItems = [];
            }
            
            const chargeVal = originalItem ? (originalItem.getAttribute('data-charge') || '0') : '0';
            // tag the element for later identification
            try { element.dataset.type = type; element.dataset.charge = chargeVal; } catch(e) {}
            inductionResult.droppedItems.push({type: type, charge: chargeVal, element: element});
            element.classList.add('real-object-animation');
            
            // Add remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.innerHTML = '√ó';
            removeBtn.onclick = function() {
                element.remove();
                // Remove from tracking array
                const index = inductionResult.droppedItems.findIndex(item => item.type === type);
                if (index > -1) {
                    inductionResult.droppedItems.splice(index, 1);
                }
            };
            
            // Add visual effects for induction
            switch(type) {
                case 'charged-rod-approach':
                    element.style.background = 'linear-gradient(145deg, #FFD700, #FFA500)';
                    element.innerHTML = '<span class="object-visual">‚ö°</span><span>Charged Rod ‚ö°</span>';
                    element.classList.add('charge-effect');
                    createFieldVisualization(fieldViz);
                    break;
                case 'neutral-conductor-sphere':
                    element.style.background = 'linear-gradient(145deg, #C0C0C0, #808080)';
                    element.innerHTML = '<span class="object-visual">‚ö™</span><span>Neutral Conductor</span>';
                    setTimeout(() => {
                        const content = element.querySelector('span:last-child');
                        if (content) content.innerHTML = 'Neutral Conductor<br><span class="positive-side">+</span> | <span class="negative-side">-</span>';
                    }, 1000);
                    break;
                case 'ground-connection':
                    element.style.background = 'linear-gradient(145deg, #8B4513, #A0522D)';
                    element.innerHTML = '<span class="object-visual">üåç</span><span>Ground Wire</span>';
                    break;
                case 'electroscope-leaves':
                    element.style.background = 'linear-gradient(145deg, #DAA520, #B8860B)';
                    element.innerHTML = '<span class="object-visual">üìè</span><span>Electroscope</span>';
                    setTimeout(() => {
                        const content = element.querySelector('span:last-child');
                        if (content) content.innerHTML = 'Electroscope<br>Leaves: <span style="color: #FFD700;">/ \\</span>';
                    }, 1000);
                    break;
                case 'metal-can':
                    element.style.background = 'linear-gradient(145deg, #C0C0C0, #808080)';
                    element.innerHTML = '<span class="object-visual">ü•´</span><span>Metal Can ‚ú®</span>';
                    break;
                case 'pith-ball':
                    element.style.background = 'linear-gradient(145deg, #F5DEB3, #DEB887)';
                    element.innerHTML = '<span class="object-visual">‚ö´</span><span>Pith Ball</span>';
                    element.classList.add('particle-animation');
                    break;
                case 'water-stream':
                    element.style.background = 'linear-gradient(145deg, #87CEEB, #4682B4)';
                    element.innerHTML = '<span class="object-visual">üíß</span><span>Water Stream</span>';
                    element.classList.add('particle-animation');
                    break;
                case 'remove-ground':
                    element.style.background = 'linear-gradient(145deg, #FF6B6B, #DC143C)';
                    element.innerHTML = '<span class="object-visual">üîå</span><span>Remove Ground</span>';
                    break;
            }
            
            element.appendChild(removeBtn);
            
            // Analyze induction process with updated state
            analyzeInductionProcess(inductionResult.droppedItems, fieldViz);
        }

        function analyzeRealObjectTriboelectric(items) {
            const rubbingResult = document.getElementById('rubbingResult');
            const triboSeries = ['fur-coat', 'glass-rod', 'human-hair', 'wool-sweater', 'silk-cloth', 'paper-pieces', 'plastic-comb', 'rubber-balloon'];
            
            if (items.length >= 2) {
                const item1 = items[items.length - 2];
                const item2 = items[items.length - 1];
                
                const pos1 = triboSeries.indexOf(item1);
                const pos2 = triboSeries.indexOf(item2);
                
                if (pos1 !== -1 && pos2 !== -1) {
                    let result = '';
                    if (pos1 < pos2) {
                        result = `<div style="color: #32CD32; font-weight: bold; margin-top: 1rem;">
                            ‚ö° Rubbing Result: ${item1.replace('-', ' ')} becomes POSITIVE (+), 
                            ${item2.replace('-', ' ')} becomes NEGATIVE (-)
                            <br>üî¨ Electrons transfer from ${item1.replace('-', ' ')} to ${item2.replace('-', ' ')}
                            <br>üí° Real example: ${getRealExample(item1, item2)}
                        </div>`;
                        createElectronAnimation();
                    } else if (pos1 > pos2) {
                        result = `<div style="color: #32CD32; font-weight: bold; margin-top: 1rem;">
                            ‚ö° Rubbing Result: ${item2.replace('-', ' ')} becomes POSITIVE (+), 
                            ${item1.replace('-', ' ')} becomes NEGATIVE (-)
                            <br>üî¨ Electrons transfer from ${item2.replace('-', ' ')} to ${item1.replace('-', ' ')}
                            <br>üí° Real example: ${getRealExample(item2, item1)}
                        </div>`;
                        createElectronAnimation();
                    }
                    
                    rubbingResult.innerHTML += result;
                }
            }
        }

        function getRealExample(positive, negative) {
            const examples = {
                'rubber-balloon_human-hair': 'Balloon sticks to hair after rubbing',
                'plastic-comb_human-hair': 'Comb attracts small paper pieces after combing',
                'wool-sweater_plastic-comb': 'Static shock when removing synthetic clothes',
                'silk-cloth_rubber-balloon': 'Balloon sticks to silk fabric',
                'fur-coat_plastic-comb': 'Pet fur sticks to plastic brush'
            };
            
            const key = `${positive}_${negative}`;
            return examples[key] || 'Objects will attract small neutral particles';
        }

        function createElectronAnimation() {
            const electronArea = document.getElementById('electronArea');
            if (!electronArea) return;
            
            for (let i = 0; i < 5; i++) {
                const electron = document.createElement('div');
                electron.className = 'electron-particle';
                electron.style.top = Math.random() * 80 + 'px';
                electron.style.left = '10px';
                electron.style.animationDelay = i * 0.3 + 's';
                electronArea.appendChild(electron);
                
                setTimeout(() => {
                    electron.remove();
                }, 2500);
            }
        }

        function analyzeConductionProcess(items, contactPoint) {
            const chargedItems = items.filter(item => item.charge === '+' || item.charge === '-');
            const neutralItems = items.filter(item => item.charge === '0');
            
            if (chargedItems.length > 0 && neutralItems.length > 0) {
                const spark = document.createElement('div');
                spark.className = 'contact-spark';
                contactPoint.appendChild(spark);
                
                const result = document.createElement('div');
                result.style.cssText = 'color: #32CD32; font-weight: bold; margin-top: 1rem; text-align: center;';
                result.innerHTML = `
                    ‚ö° Conduction Complete!<br>
                    Electrons flow through direct contact<br>
                    Both objects now have ${chargedItems[0].charge === '+' ? 'POSITIVE' : 'NEGATIVE'} charge<br>
                    üí° Real example: Touching a Van de Graaff generator
                `;
                contactPoint.parentNode.appendChild(result);
                
                setTimeout(() => {
                    spark.remove();
                }, 3000);
            }
        }

        function createFieldVisualization(fieldViz) {
            for (let i = 0; i < 8; i++) {
                const line = document.createElement('div');
                line.className = 'field-line';
                line.style.top = (i * 15 + 20) + 'px';
                line.style.left = '20px';
                line.style.width = '60px';
                line.style.animationDelay = i * 0.2 + 's';
                fieldViz.appendChild(line);
            }
        }

        // Induction manager: handles polarization, grounding, removal order and final charge-locking
        function analyzeInductionProcess(items, fieldViz) {
            if (!window.inductionState) {
                window.inductionState = { polarized: false, grounded: false, pendingCharge: null, locked: false, lockedCharge: null };
            }
            const state = window.inductionState;

            // Determine presence of objects
            const rod = items.find(i => i.type && i.type.indexOf('charged-rod') >= 0);
            const conductor = items.find(i => i.type && (i.type.indexOf('conductor') >= 0 || i.type.indexOf('electroscope') >= 0 || i.type.indexOf('metal-can') >= 0 || i.type.indexOf('neutral-conductor') >= 0));
            const ground = items.find(i => i.type && (i.type.indexOf('ground') >= 0 || i.type === 'ground-wire' || i.type === 'ground-connection'));
            const removeGround = items.find(i => i.type === 'remove-ground');

            const parent = fieldViz && fieldViz.parentNode ? fieldViz.parentNode : document.getElementById('inductionDisplay') || document.getElementById('inductionResult');

            // Helper to clear previous helper visuals
            const clearHelpers = () => {
                if (!parent) return;
                const old = parent.querySelectorAll('.induction-helper');
                old.forEach(n => n.remove());
            };

            // If a charged rod is near a neutral conductor => polarization (no net charge change)
            if (rod && conductor && !state.polarized) {
                state.polarized = true;
                state.grounded = false;
                state.locked = false;
                state.pendingCharge = null;

                clearHelpers();
                const helper = document.createElement('div');
                helper.className = 'induction-helper';
                helper.style.cssText = 'color:#87CEEB;font-weight:700;margin-top:0.7rem;text-align:center;';
                const rodChargeRaw = (rod.charge || rod.charge === 0) ? String(rod.charge) : (rod.charge === undefined ? '+' : String(rod.charge));
                const rodPositive = (rodChargeRaw === '+' || rodChargeRaw === 'positive');

                // Show polarization explanation and clear visual split
                helper.innerHTML = `üß≤ Polarization: charges separate within the conductor (no net charge).<br>` +
                                    (rodPositive ? 'Electrons gather on the side near the + rod (‚àí near, + far).' : 'Electrons are repelled from the side near the ‚àí rod (+ near, ‚àí far).');
                parent.appendChild(helper);

                // small separation visual
                const separation = document.createElement('div');
                separation.className = 'induction-helper';
                separation.style.cssText = 'display:flex;justify-content:center;gap:1rem;margin-top:0.6rem;font-weight:800;color:#FFD700;';
                if (rodPositive) {
                    separation.innerHTML = `<span style="color:#87CEEB;">‚àí ‚àí ‚àí (near)</span><span style="color:white;">|</span><span style="color:#FF6B6B;">+ + + (far)</span>`;
                } else {
                    separation.innerHTML = `<span style="color:#FF6B6B;">+ + + (near)</span><span style="color:white;">|</span><span style="color:#87CEEB;">‚àí ‚àí ‚àí (far)</span>`;
                }
                parent.appendChild(separation);

                try { if (typeof soundManager !== 'undefined') soundManager.playRub(); } catch(e){}
            }

            // If grounded while polarized => electrons flow to/from ground (pending net charge)
            if (state.polarized && ground && !state.grounded) {
                state.grounded = true;
                // pending charge is opposite of rod
                const rodObj = rod;
                const rodChargeRaw = (rodObj && (rodObj.charge || rodObj.charge === 0)) ? String(rodObj.charge) : '+';
                const rodPositive = (rodChargeRaw === '+' || rodChargeRaw === 'positive');
                state.pendingCharge = rodPositive ? 'negative' : 'positive';

                clearHelpers();
                const g = document.createElement('div');
                g.className = 'induction-helper';
                g.style.cssText = 'color:#32CD32;font-weight:800;margin-top:0.6rem;text-align:center;';
                g.innerHTML = `üåç Ground connected: electrons ${state.pendingCharge === 'negative' ? 'flow from ground into conductor' : 'flow from conductor to ground'} (while rod is present).`;
                parent.appendChild(g);

                // small animation marker
                const flow = document.createElement('div');
                flow.className = 'induction-helper';
                flow.style.cssText = 'text-align:center;color:#87CEEB;margin-top:0.4rem;';
                flow.innerHTML = state.pendingCharge === 'negative' ? '‚¨áÔ∏è ground ‚Üí conductor' : '‚¨ÜÔ∏è conductor ‚Üí ground';
                parent.appendChild(flow);
                try { if (typeof soundManager !== 'undefined') soundManager.playSpark(); } catch(e){}
            }

            // If remove-ground is dropped while grounded => lock in the pending charge (ground removed before rod)
            if (state.grounded && removeGround) {
                // lock in
                state.grounded = false;
                state.locked = true;
                state.lockedCharge = state.pendingCharge;

                clearHelpers();
                const lock = document.createElement('div');
                lock.className = 'induction-helper';
                lock.style.cssText = 'color:#FFD700;font-weight:900;margin-top:0.6rem;text-align:center;';
                lock.innerHTML = `üîí Ground removed ‚Äî charge imbalance locked: conductor will be <strong>${state.lockedCharge.toUpperCase()}</strong> once the rod is removed.`;
                parent.appendChild(lock);
                try { if (typeof soundManager !== 'undefined') soundManager.playClick(); } catch(e){}
            }

            // If rod removed while we have a locked charge => finalize (conductor remains charged)
            if (!rod && state.locked && conductor) {
                // finalize result
                clearHelpers();
                const finished = document.createElement('div');
                finished.className = 'induction-helper';
                finished.style.cssText = 'color:#32CD32;font-weight:900;margin-top:0.6rem;text-align:center;';
                finished.innerHTML = `‚úÖ Induction complete ‚Äî conductor is now <strong>${state.lockedCharge.toUpperCase()}</strong> (opposite of the rod).`;
                parent.appendChild(finished);

                // If we have a DOM element for the conductor, update its appearance/metadata
                try {
                    const conductorEl = (conductor && conductor.element) ? conductor.element : (parent.querySelector('[data-type*="conductor"]') || parent.querySelector('.induction-item'));
                    if (conductorEl) {
                        conductorEl.dataset.charge = state.lockedCharge === 'negative' ? '-' : (state.lockedCharge === 'positive' ? '+' : '0');
                        conductorEl.classList.add('induced-locked');
                        // update inner label to show final charge
                        const label = document.createElement('div');
                        label.style.cssText = 'margin-top:6px;font-weight:800;color:#87CEEB;';
                        label.innerHTML = `Final charge: <span style="color:${state.lockedCharge==='negative'?'#87CEEB':'#FF6B6B'}">${state.lockedCharge==='negative'?'-':(state.lockedCharge==='positive'?'+':'0')}</span>`;
                        conductorEl.appendChild(label);
                    }
                } catch(e) {}

                // reset induction state after finalizing
                window.inductionState = { polarized: false, grounded: false, pendingCharge: null, locked: false, lockedCharge: null };
                try { if (typeof soundManager !== 'undefined') soundManager.playZap(); } catch(e){}
            }

            // If rod removed and no lock occurred -> clear polarization
            if (!rod && !state.locked) {
                // simply clear helpers and reset
                clearHelpers();
                window.inductionState = { polarized: false, grounded: false, pendingCharge: null, locked: false, lockedCharge: null };
            }
        }

        function analyzeTriboelectricEffect(items) {
            const chargingResult = document.getElementById('chargingResult');
            const triboSeries = ['glass-rod', 'wool-cloth', 'silk-cloth', 'plastic-rod', 'rubber-balloon'];
            
            if (items.length >= 2) {
                const item1 = items[items.length - 2];
                const item2 = items[items.length - 1];
                
                const pos1 = triboSeries.indexOf(item1);
                const pos2 = triboSeries.indexOf(item2);
                
                if (pos1 !== -1 && pos2 !== -1) {
                    let result = '';
                    if (pos1 < pos2) {
                        result = `<div style="color: #32CD32; font-weight: bold; margin-top: 1rem;">
                            ‚ö° Rubbing Result: ${item1.replace('-', ' ')} becomes POSITIVE (+), 
                            ${item2.replace('-', ' ')} becomes NEGATIVE (-)
                            <br>Electrons transfer from ${item1.replace('-', ' ')} to ${item2.replace('-', ' ')}
                        </div>`;
                    } else if (pos1 > pos2) {
                        result = `<div style="color: #32CD32; font-weight: bold; margin-top: 1rem;">
                            ‚ö° Rubbing Result: ${item2.replace('-', ' ')} becomes POSITIVE (+), 
                            ${item1.replace('-', ' ')} becomes NEGATIVE (-)
                            <br>Electrons transfer from ${item2.replace('-', ' ')} to ${item1.replace('-', ' ')}
                        </div>`;
                    }
                    
                    chargingResult.innerHTML += result;
                }
            }
        }

        function handleInductionDrop(element, type, originalItem) {
            const inductionDisplay = document.getElementById('inductionDisplay');
            
            switch(type) {
                case 'charged-rod':
                    element.style.background = 'linear-gradient(145deg, #FFD700, #FFA500)';
                    element.innerHTML += ' ‚ö°üîã';
                    element.classList.add('charge-effect');
                    
                    // Create field lines animation
                    createFieldLinesAnimation(inductionDisplay);
                    break;
                case 'neutral-conductor':
                    element.style.background = 'linear-gradient(145deg, #C0C0C0, #808080)';
                    element.innerHTML += ' üîå';
                    
                    // Show charge separation
                    setTimeout(() => {
                        element.innerHTML += '<br><span style="color: #FF6B6B;">+</span> | <span style="color: #87CEEB;">-</span>';
                    }, 1000);
                    break;
                case 'ground-wire':
                    element.style.background = 'linear-gradient(145deg, #8B4513, #A0522D)';
                    element.innerHTML += ' üåç';
                    break;
                case 'water-molecule':
                    element.style.background = 'linear-gradient(145deg, #87CEEB, #4682B4)';
                    element.innerHTML += ' üíß';
                    element.classList.add('particle-animation');
                    
                    // Show dipole formation
                    setTimeout(() => {
                        element.innerHTML += '<br><span style="color: #FF6B6B;">Œ¥+</span>-<span style="color: #87CEEB;">Œ¥-</span>';
                    }, 1000);
                    break;
                case 'paper-bits':
                    element.style.background = 'linear-gradient(145deg, #F5F5DC, #DDD)';
                    element.innerHTML += ' üìÑ';
                    element.classList.add('particle-animation');
                    break;
                case 'electroscope':
                    element.style.background = 'linear-gradient(145deg, #DAA520, #B8860B)';
                    element.innerHTML += ' üìè‚ö°';
                    
                    // Show leaf deflection
                    setTimeout(() => {
                        element.innerHTML += '<br>Leaves: <span style="color: #FFD700;">/ \\</span>';
                    }, 1000);
                    break;
            }
        }

        function createFieldLinesAnimation(container) {
            // Add animated field lines
            for (let i = 0; i < 5; i++) {
                const line = document.createElement('div');
                line.style.cssText = `
                    position: absolute;
                    width: 2px;
                    height: 50px;
                    background: linear-gradient(to bottom, #FFD700, transparent);
                    left: ${20 + i * 20}%;
                    top: 20%;
                    animation: fieldLine 2s ease-in-out infinite;
                    animation-delay: ${i * 0.2}s;
                `;
                container.appendChild(line);
            }
        }

        function addPhysicsAnimation(element, type) {
            switch(type) {
                case 'positive-charge':
                    element.style.boxShadow = '0 0 20px #FFD700';
                    element.innerHTML += ' ‚ö°';
                    break;
                case 'negative-charge':
                    element.style.boxShadow = '0 0 20px #87CEEB';
                    element.innerHTML += ' ‚ö°';
                    break;
                case 'electric-field':
                    element.style.background = 'linear-gradient(90deg, #32CD32, #228B22, #32CD32)';
                    element.innerHTML += ' ‚ÜóÔ∏è‚ÜòÔ∏è';
                    break;
                case 'conductor':
                    element.style.background = 'linear-gradient(145deg, #C0C0C0, #808080)';
                    element.innerHTML += ' üîå';
                    break;
                case 'insulator':
                    element.style.background = 'linear-gradient(145deg, #8B4513, #A0522D)';
                    element.innerHTML += ' üö´';
                    break;
            }
        }

        // Remove individual dropped items
        function removeDroppedItem(element, itemType, zoneId) {
            // Update particle count for atom zone
            if (zoneId === 'atomZone') {
                switch(itemType) {
                    case 'proton':
                        particleCount.protons--;
                        totalCharge -= 1.6e-19;
                        break;
                    case 'electron':
                        particleCount.electrons--;
                        totalCharge += 1.6e-19;
                        break;
                    case 'neutron':
                        particleCount.neutrons--;
                        break;
                    case 'ion-positive':
                        totalCharge -= 3.2e-19;
                        break;
                    case 'ion-negative':
                        totalCharge += 3.2e-19;
                        break;
                }
                updateChargeDisplay();
            }
            
            // Remove from tracking arrays if needed
            const resultContainers = {
                'rubbingZone': document.getElementById('rubbingResult'),
                'conductionZone': document.getElementById('conductionResult'),
                'inductionZone': document.getElementById('inductionResult')
            };
            
            const container = resultContainers[zoneId];
            if (container && container.droppedItems) {
                const index = container.droppedItems.indexOf(itemType);
                if (index > -1) {
                    container.droppedItems.splice(index, 1);
                }
            }
            
            // Remove the element with animation
            element.style.animation = 'dropAnimation 0.3s ease-out reverse';
            setTimeout(() => {
                element.remove();
            }, 300);
        }

        // Clear entire simulation areas

        function clearRubbingArea() {
            const simulationArea = document.getElementById('simulationArea');
            const chargingResults = document.getElementById('chargingResults');
            const electronTransferArea = document.getElementById('electronTransferArea');
            
            try { soundManager.playReset(); } catch(e){}
            // Clear all objects
            simulationArea.innerHTML = '<div style="color: #FFD700; font-style: italic; font-size: 1.2rem; width: 100%; text-align: center;">Drop objects here to start rubbing simulation</div>';
            chargingResults.innerHTML = '';
            electronTransferArea.innerHTML = '';
            
            // Reset tracking array
            simulationArea.droppedItems = [];
        }

        function clearConductionArea() {
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            const conductionResults = document.getElementById('conductionResults');
            
            try { soundManager.playReset(); } catch(e){}
            // Clear all objects with animation
            if (conductionSimulationArea.droppedItems) {
                conductionSimulationArea.droppedItems.forEach(item => {
                    if (item.element && item.element.parentNode) {
                        item.element.style.animation = 'dropAnimation 0.3s ease-out reverse';
                        setTimeout(() => {
                            if (item.element.parentNode) {
                                item.element.remove();
                            }
                        }, 300);
                    }
                });
            }
            
            // Reset content and tracking array
            setTimeout(() => {
                conductionSimulationArea.innerHTML = '<div style="color: #FFD700; font-style: italic; font-size: 1.2rem; width: 100%; text-align: center;">Drop objects here, then touch charged to neutral objects!</div>';
                conductionResults.innerHTML = '';
                conductionSimulationArea.droppedItems = [];
            }, 400);
        }

        // Conduction simulation functions
        function handleConductionDrop(type, originalItem) {
            // Create simulation object in the conduction area
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            const objectData = getConductionObjectData(type);
            const charge = originalItem.getAttribute('data-charge');
            
            // Initialize tracking array if needed
            if (!conductionSimulationArea.droppedItems) {
                conductionSimulationArea.droppedItems = [];
            }
            
            // Clear placeholder text if this is the first object
            if (conductionSimulationArea.droppedItems.length === 0) {
                conductionSimulationArea.innerHTML = '';
            }
            
            // Create simulation object
            const simObject = document.createElement('div');
            simObject.className = 'simulation-object';
            simObject.dataset.type = type;
            simObject.dataset.charge = charge;
            simObject.dataset.originalCharge = charge; // Store original charge
            simObject.draggable = true;
            
            simObject.innerHTML = `
                <div class="object-icon">${objectData.icon}</div>
                <div class="object-name">${objectData.name}</div>
                <div class="charge-indicator" style="display: ${charge !== 'neutral' ? 'flex' : 'none'};">${getChargeSymbol(charge)}</div>
                <button class="remove-btn" onclick="removeConductionObject(this.parentElement, '${type}')">√ó</button>
            `;
            
            // Set initial charge appearance
            updateConductionObjectAppearance(simObject, charge);
            
            // Make the simulation object draggable within the simulation area
            setupConductionObjectDrag(simObject);
            
            conductionSimulationArea.appendChild(simObject);
            
            // Add to tracking array
            conductionSimulationArea.droppedItems.push({
                element: simObject,
                type: type,
                charge: charge,
                originalCharge: charge
            });
        }

        function getConductionObjectData(type) {
            const objectMap = {
                // Charged Objects
                'charged-rod-positive': {
                    name: 'Charged Glass Rod (+)',
                    icon: '‚ö°',
                    material: 'Glass Rod'
                },
                'charged-rod-negative': {
                    name: 'Charged Plastic Rod (-)',
                    icon: '‚ö°',
                    material: 'Plastic Rod'
                },
                'van-de-graaff': {
                    name: 'Van de Graaff Generator',
                    icon: 'üîÆ',
                    material: 'Electrostatic Generator'
                },
                'charged-balloon': {
                    name: 'Charged Balloon (-)',
                    icon: 'üéà',
                    material: 'Rubber Balloon'
                },
                'charged-comb': {
                    name: 'Charged Comb (-)',
                    icon: 'üíá',
                    material: 'Plastic Comb'
                },
                'charged-socks': {
                    name: 'Charged Socks (-)',
                    icon: 'üß¶',
                    material: 'Synthetic Fabric'
                },
                'charged-sweater': {
                    name: 'Charged Sweater (+)',
                    icon: 'üß•',
                    material: 'Wool Fabric'
                },
                'lightning-cloud': {
                    name: 'Storm Cloud (-)',
                    icon: '‚õàÔ∏è',
                    material: 'Charged Cloud'
                },
                
                // Neutral Conductors
                'human-hand': {
                    name: 'Human Hand',
                    icon: '‚úã',
                    material: 'Human Body (Conductor)'
                },
                'metal-sphere': {
                    name: 'Metal Sphere',
                    icon: '‚ö™',
                    material: 'Metal Conductor'
                },
                'copper-wire': {
                    name: 'Copper Wire',
                    icon: 'üî∂',
                    material: 'Copper Conductor'
                },
                'aluminum-foil': {
                    name: 'Aluminum Foil',
                    icon: 'üìÑ',
                    material: 'Aluminum Conductor'
                },
                'metal-spoon': {
                    name: 'Metal Spoon',
                    icon: 'ü•Ñ',
                    material: 'Metal Utensil'
                },
                'coin': {
                    name: 'Coin',
                    icon: 'ü™ô',
                    material: 'Metal Currency'
                },
                'car-body': {
                    name: 'Car Body',
                    icon: 'üöó',
                    material: 'Metal Vehicle'
                },
                'metal-doorknob': {
                    name: 'Metal Doorknob',
                    icon: 'üö™',
                    material: 'Metal Hardware'
                },
                'water-faucet': {
                    name: 'Water Faucet',
                    icon: 'üö∞',
                    material: 'Metal Plumbing'
                },
                'metal-chair': {
                    name: 'Metal Chair',
                    icon: 'ü™ë',
                    material: 'Metal Furniture'
                },
                'electroscope': {
                    name: 'Electroscope',
                    icon: 'üìè',
                    material: 'Scientific Instrument'
                },
                'person-body': {
                    name: 'Person',
                    icon: 'üßç',
                    material: 'Human Body (Conductor)'
                }
            };
            
            return objectMap[type] || {name: 'Unknown', icon: '‚ùì', material: 'Unknown'};
        }

        function getChargeSymbol(charge) {
            switch(charge) {
                case 'positive': return '+';
                case 'negative': return '-';
                case 'neutral': return '';
                default: return '';
            }
        }

        function updateConductionObjectAppearance(simObject, charge) {
            const chargeIndicator = simObject.querySelector('.charge-indicator');
            
            // Remove existing charge classes
            simObject.classList.remove('charged-positive', 'charged-negative', 'neutral-object');
            
            switch(charge) {
                case 'positive':
                    simObject.classList.add('charged-positive');
                    chargeIndicator.className = 'charge-indicator positive';
                    chargeIndicator.innerHTML = '+';
                    chargeIndicator.style.display = 'flex';
                    break;
                case 'negative':
                    simObject.classList.add('charged-negative');
                    chargeIndicator.className = 'charge-indicator negative';
                    chargeIndicator.innerHTML = '-';
                    chargeIndicator.style.display = 'flex';
                    break;
                case 'neutral':
                    simObject.classList.add('neutral-object');
                    chargeIndicator.style.display = 'none';
                    break;
            }
        }

        function setupConductionObjectDrag(simObject) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            simObject.addEventListener('mousedown', function(e) {
                // Don't start drag if clicking on remove button
                if (e.target.classList.contains('remove-btn')) {
                    return;
                }
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = simObject.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                simObject.style.cursor = 'grabbing';
                simObject.style.zIndex = '1000';
                simObject.style.transform = 'scale(1.05)';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const newX = initialX + deltaX;
                const newY = initialY + deltaY;
                
                // Keep object within simulation area bounds
                const conductionSimulationArea = document.getElementById('conductionSimulationArea');
                const simRect = conductionSimulationArea.getBoundingClientRect();
                const objRect = simObject.getBoundingClientRect();
                
                const minX = simRect.left;
                const maxX = simRect.right - objRect.width;
                const minY = simRect.top;
                const maxY = simRect.bottom - objRect.height;
                
                const boundedX = Math.max(minX, Math.min(maxX, newX));
                const boundedY = Math.max(minY, Math.min(maxY, newY));
                
                simObject.style.position = 'absolute';
                simObject.style.left = (boundedX - simRect.left) + 'px';
                simObject.style.top = (boundedY - simRect.top) + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (!isDragging) return;
                
                isDragging = false;
                simObject.style.cursor = 'grab';
                simObject.style.zIndex = 'auto';
                simObject.style.transform = 'scale(1)';
                
                // Check for contact with other objects for conduction effect
                checkForConductionContact(simObject);
            });
            
            // Set initial cursor
            simObject.style.cursor = 'grab';
        }

        function checkForConductionContact(draggedObject) {
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            const allObjects = conductionSimulationArea.querySelectorAll('.simulation-object');
            
            const draggedRect = draggedObject.getBoundingClientRect();
            
            allObjects.forEach(otherObject => {
                if (otherObject === draggedObject) return;
                
                const otherRect = otherObject.getBoundingClientRect();
                
                // Check if objects are overlapping (touching)
                const distance = Math.sqrt(
                    Math.pow(draggedRect.left - otherRect.left, 2) + 
                    Math.pow(draggedRect.top - otherRect.top, 2)
                );
                
                if (distance < 60) { // Objects are touching
                    triggerConductionEffect(draggedObject, otherObject);
                }
            });
        }

        function triggerConductionEffect(obj1, obj2) {
            const charge1 = obj1.dataset.charge;
            const charge2 = obj2.dataset.charge;
            
            // Conduction only occurs between charged and neutral objects, or between conductors
            let chargedObject = null;
            let neutralObject = null;
            
            if (charge1 !== 'neutral' && charge2 === 'neutral') {
                chargedObject = obj1;
                neutralObject = obj2;
            } else if (charge1 === 'neutral' && charge2 !== 'neutral') {
                chargedObject = obj2;
                neutralObject = obj1;
            } else if (charge1 !== 'neutral' && charge2 !== 'neutral' && charge1 !== charge2) {
                // Two differently charged objects - they will neutralize each other partially
                handleChargeNeutralization(obj1, obj2);
                return;
            } else {
                // No conduction occurs (both neutral or same charge)
                return;
            }
            
            // Perform conduction
            performConduction(chargedObject, neutralObject);
        }

        function performConduction(chargedObject, neutralObject) {
            // Show contact spark effect
            createConductionSpark(chargedObject, neutralObject);
            try { if (typeof soundManager !== 'undefined') soundManager.playZap(); } catch(e){}
            
            // Show electron flow animation
            showConductionElectronFlow(chargedObject, neutralObject);
            
            // Transfer charge to neutral object
            const originalCharge = chargedObject.dataset.charge;
            
            setTimeout(() => {
                // Transfer: neutral object adopts the charged object's net charge
                neutralObject.dataset.charge = originalCharge;
                updateConductionObjectAppearance(neutralObject, originalCharge);

                // Update results display
                displayConductionResults(chargedObject, neutralObject, originalCharge);
            }, 1500);
        }

        function handleChargeNeutralization(obj1, obj2) {
            // Show neutralization spark
            createConductionSpark(obj1, obj2);
            
            // Show bidirectional electron flow
            showNeutralizationElectronFlow(obj1, obj2);
            
            setTimeout(() => {
                // Both objects become neutral
                obj1.dataset.charge = 'neutral';
                obj2.dataset.charge = 'neutral';
                updateConductionObjectAppearance(obj1, 'neutral');
                updateConductionObjectAppearance(obj2, 'neutral');
                
                // Update results display
                displayNeutralizationResults(obj1, obj2);
            }, 1500);
        }

        function createConductionSpark(obj1, obj2) {
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            const rect1 = obj1.getBoundingClientRect();
            const rect2 = obj2.getBoundingClientRect();
            const simRect = conductionSimulationArea.getBoundingClientRect();
            
            // Calculate contact point between objects
            const contactX = ((rect1.left + rect1.width/2) + (rect2.left + rect2.width/2)) / 2 - simRect.left;
            const contactY = ((rect1.top + rect1.height/2) + (rect2.top + rect2.height/2)) / 2 - simRect.top;
            
            // Create contact spark
            const spark = document.createElement('div');
            spark.style.cssText = `
                position: absolute;
                width: 30px;
                height: 30px;
                background: radial-gradient(circle, #FFD700, #FFA500, transparent);
                border-radius: 50%;
                left: ${contactX - 15}px;
                top: ${contactY - 15}px;
                animation: sparkEffect 1s ease-out;
                z-index: 999;
            `;
            conductionSimulationArea.appendChild(spark);
            try { soundManager.playSpark(); } catch(e){}
            
            // Remove spark after animation
            setTimeout(() => {
                if (spark.parentNode) {
                    spark.remove();
                }
            }, 1000);
        }

        function showConductionElectronFlow(fromObject, toObject) {
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            const fromRect = fromObject.getBoundingClientRect();
            const toRect = toObject.getBoundingClientRect();
            const simRect = conductionSimulationArea.getBoundingClientRect();
            
            // Calculate positions relative to simulation area
            const startX = (fromRect.left + fromRect.width/2) - simRect.left;
            const startY = (fromRect.top + fromRect.height/2) - simRect.top;
            const endX = (toRect.left + toRect.width/2) - simRect.left;
            const endY = (toRect.top + toRect.height/2) - simRect.top;
            
            // Create electron flow particles
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const electron = document.createElement('div');
                    electron.className = 'electron-transfer-particle';
                    electron.style.left = startX + 'px';
                    electron.style.top = startY + 'px';
                    
                    conductionSimulationArea.appendChild(electron);
                    
                    // Animate electron from charged to neutral object
                    let progress = 0;
                    const animationSpeed = 0.03;
                    
                    const moveElectron = () => {
                        progress += animationSpeed;
                        
                        if (progress >= 1) {
                            electron.remove();
                            return;
                        }
                        
                        const currentX = startX + (endX - startX) * progress;
                        const currentY = startY + (endY - startY) * progress;
                        
                        electron.style.left = currentX + 'px';
                        electron.style.top = currentY + 'px';
                        
                        requestAnimationFrame(moveElectron);
                    };
                    
                    requestAnimationFrame(moveElectron);
                }, i * 100);
            }
        }

        function showNeutralizationElectronFlow(obj1, obj2) {
            // Show electrons flowing both ways for neutralization
            showConductionElectronFlow(obj1, obj2);
            setTimeout(() => {
                showConductionElectronFlow(obj2, obj1);
            }, 200);
        }

        function displayConductionResults(chargedObject, neutralObject, finalCharge) {
            const resultsArea = document.getElementById('conductionResults');
            
            const chargedName = chargedObject.querySelector('.object-name').textContent;
            const neutralName = neutralObject.querySelector('.object-name').textContent;
            const chargeSymbol = finalCharge === 'positive' ? '+' : '-';
            const chargeColor = finalCharge === 'positive' ? '#FF6B6B' : '#87CEEB';
            
            // Get realistic example based on the objects involved
            const realExample = getConductionRealExample(chargedObject.dataset.type, neutralObject.dataset.type);
            
            resultsArea.innerHTML = `
                <div style="background: rgba(255, 215, 0, 0.1); border-radius: 10px; padding: 1.5rem; border: 1px solid #FFD700;">
                    <h4 style="color: #FFD700; margin-bottom: 1rem;">‚ö° Conduction Complete!</h4>
                    <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 1rem; align-items: center; margin-bottom: 1rem;">
                        <div style="text-align: center;">
                            <div style="color: ${chargeColor}; font-weight: bold; font-size: 1.2rem;">${chargedName}</div>
                            <div style="color: white; font-size: 0.9rem;">Originally charged (${chargeSymbol})</div>
                        </div>
                        <div style="color: #FFD700; font-size: 2rem;">‚Üí</div>
                        <div style="text-align: center;">
                            <div style="color: ${chargeColor}; font-weight: bold; font-size: 1.2rem;">${neutralName}</div>
                            <div style="color: white; font-size: 0.9rem;">Now charged (${chargeSymbol})</div>
                        </div>
                    </div>
                    <div style="color: #32CD32; text-align: center; font-weight: bold; margin-bottom: 1rem;">
                        üí° Both objects now have the same ${finalCharge} charge!
                    </div>
                    <div style="color: #87CEEB; text-align: center; font-size: 0.9rem; margin-bottom: 1rem;">
                        Electrons flowed through direct contact until both objects reached the same electric potential
                    </div>
                    <div style="color: #FFD700; text-align: center; font-weight: bold; background: rgba(0,0,0,0.3); padding: 0.8rem; border-radius: 8px;">
                        üåü Real-Life Example: ${realExample}
                    </div>
                </div>
            `;
        }
        
        function getConductionRealExample(chargedType, neutralType) {
            const examples = {
                'van-de-graaff_human-hand': 'Touching a Van de Graaff generator dome - your hair stands up as your body becomes charged!',
                'van-de-graaff_person-body': 'Science museum demonstration - person becomes charged and can light up fluorescent bulbs!',
                'charged-balloon_human-hand': 'Balloon sticks to your hand after rubbing - electrons transfer through your skin',
                'charged-comb_human-hand': 'Static shock when touching a charged comb - common after combing dry hair',
                'charged-socks_metal-doorknob': 'Static shock when touching doorknob after walking on carpet in socks',
                'lightning-cloud_car-body': 'Lightning strike on car - charge spreads across metal body (Faraday cage effect)',
                'charged-sweater_water-faucet': 'Static discharge when touching metal faucet after removing wool sweater',
                'charged-rod-positive_coin': 'Physics lab demonstration - charged rod transfers charge to metal objects',
                'charged-rod-negative_metal-sphere': 'Classic electrostatics experiment showing charge transfer to conductors',
                'van-de-graaff_electroscope': 'Electroscope leaves spread apart when touched by charged generator dome'
            };
            
            const key1 = `${chargedType}_${neutralType}`;
            const key2 = `${neutralType}_${chargedType}`;
            
            return examples[key1] || examples[key2] || 'Charge transfers from one object to another through direct contact - like getting a static shock!';
        }

        function displayNeutralizationResults(obj1, obj2) {
            const resultsArea = document.getElementById('conductionResults');
            
            const name1 = obj1.querySelector('.object-name').textContent;
            const name2 = obj2.querySelector('.object-name').textContent;
            
            resultsArea.innerHTML = `
                <div style="background: rgba(255, 215, 0, 0.1); border-radius: 10px; padding: 1.5rem; border: 1px solid #FFD700;">
                    <h4 style="color: #FFD700; margin-bottom: 1rem;">‚ö° Charge Neutralization!</h4>
                    <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 1rem; align-items: center; margin-bottom: 1rem;">
                        <div style="text-align: center;">
                            <div style="color: #C0C0C0; font-weight: bold; font-size: 1.2rem;">${name1}</div>
                            <div style="color: white; font-size: 0.9rem;">Now neutral</div>
                        </div>
                        <div style="color: #FFD700; font-size: 2rem;">‚ö°</div>
                        <div style="text-align: center;">
                            <div style="color: #C0C0C0; font-weight: bold; font-size: 1.2rem;">${name2}</div>
                            <div style="color: white; font-size: 0.9rem;">Now neutral</div>
                        </div>
                    </div>
                    <div style="color: #32CD32; text-align: center; font-weight: bold; margin-bottom: 1rem;">
                        üí° Opposite charges canceled each other out!
                    </div>
                    <div style="color: #87CEEB; text-align: center; font-size: 0.9rem;">
                        Electrons flowed between objects until charges balanced
                    </div>
                </div>
            `;
        }

        function autoTouchObjects() {
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            const allObjects = conductionSimulationArea.querySelectorAll('.simulation-object');
            
            if (allObjects.length < 2) {
                const message = document.createElement('div');
                message.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 0, 0, 0.8); color: white; padding: 1rem; border-radius: 8px; z-index: 1000; font-weight: bold;';
                message.textContent = 'Need at least 2 objects for conduction!';
                conductionSimulationArea.appendChild(message);
                setTimeout(() => message.remove(), 2000);
                return;
            }
            
            // Find a charged object and a neutral object
            let chargedObject = null;
            let neutralObject = null;
            
            for (let obj of allObjects) {
                if (obj.dataset.charge !== 'neutral' && !chargedObject) {
                    chargedObject = obj;
                } else if (obj.dataset.charge === 'neutral' && !neutralObject) {
                    neutralObject = obj;
                }
                
                if (chargedObject && neutralObject) break;
            }
            
            if (!chargedObject || !neutralObject) {
                const message = document.createElement('div');
                message.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 165, 0, 0.8); color: white; padding: 1rem; border-radius: 8px; z-index: 1000; font-weight: bold;';
                message.textContent = 'Need both charged and neutral objects for conduction!';
                conductionSimulationArea.appendChild(message);
                setTimeout(() => message.remove(), 2000);
                return;
            }
            
            // Position objects close together
            const simRect = conductionSimulationArea.getBoundingClientRect();
            const centerX = simRect.width / 2 - 60;
            const centerY = simRect.height / 2 - 50;
            
            chargedObject.style.position = 'absolute';
            chargedObject.style.left = (centerX - 80) + 'px';
            chargedObject.style.top = centerY + 'px';
            
            neutralObject.style.position = 'absolute';
            neutralObject.style.left = (centerX + 80) + 'px';
            neutralObject.style.top = centerY + 'px';
            
            // Trigger conduction effect
            setTimeout(() => {
                triggerConductionEffect(chargedObject, neutralObject);
                try { soundManager.playZap(); } catch(e){}
            }, 500);
        }

        function removeConductionObject(element, type) {
            const conductionSimulationArea = document.getElementById('conductionSimulationArea');
            
            // Remove from tracking array
            if (conductionSimulationArea.droppedItems) {
                conductionSimulationArea.droppedItems = conductionSimulationArea.droppedItems.filter(item => item.element !== element);
            }
            
            // Remove element with animation
            element.style.animation = 'dropAnimation 0.3s ease-out reverse';
            setTimeout(() => {
                element.remove();
                
                // Reset simulation area if empty
                if (conductionSimulationArea.children.length === 0) {
                    conductionSimulationArea.innerHTML = '<div style="color: #FFD700; font-style: italic; font-size: 1.2rem; width: 100%; text-align: center;">Drop objects here, then touch charged to neutral objects!</div>';
                    document.getElementById('conductionResults').innerHTML = '';
                }
            }, 300);
        }

        function clearInductionArea() {
            const inductionZone = document.getElementById('inductionZone');
            const droppedItems = inductionZone.querySelectorAll('.dropped-item');
            
            try { soundManager.playReset(); } catch(e){}
            droppedItems.forEach(item => {
                item.style.animation = 'dropAnimation 0.3s ease-out reverse';
                setTimeout(() => {
                    item.remove();
                }, 300);
            });
            
            // Reset induction result
            const inductionResult = document.getElementById('inductionResult');
            inductionResult.innerHTML = `
                <div style="text-align: center; color: #FFD700; margin: 1rem 0;">
                    Bring charged object near neutral conductor (no touching!)
                </div>
                <div id="fieldViz" style="position: relative; height: 120px; background: rgba(0,0,0,0.2); border-radius: 8px; overflow: hidden;">
                    <div class="field-lines"></div>
                </div>
            `;
            
            if (inductionResult.droppedItems) {
                inductionResult.droppedItems = [];
            }
        }
    </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9963fb5157d2d007',t:'MTc2MTc1NDYzMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>